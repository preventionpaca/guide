<!DOCTYPE html>
<html lang="fr">
<head>
  <script>window.PP_APP_NAME = "equipements";</script>

  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Répartition des travaux réglementés par diplôme en PACA</title>
  
  <!-- Portail Prévention PACA (GitHub) -->
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-core.css" />
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-portail.css" />
  <script>window.PP_AUTH_DISABLED = true;</script>
<script src="https://preventionpaca.github.io/guide/js/pp-config.js"></script>
  <script>
    // Page: Analyse diplômes (GitHub)
    window.PP_APP_NAME = window.PP_APP_NAME || "equipements";
  </script>

<!-- API Grist supprimée (GitHub-only) -->

  <!-- PPP Data Layer supprimé: utilisation de pp-config.js -->


<!-- Chart.js + plugin datalabels -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

  <!-- Export (capture + PDF) -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  

  

<style>
  /* Page-specific layout only (theme handled by pp-core.css / pp-portail.css) */
  .app{max-width:1100px;margin:0 auto;padding:24px 16px 60px;}
  .card{background:#fff;border-radius:16px;padding:18px;border:1px solid rgba(0,0,0,.08);}
  .title{margin:0 0 10px 0;font-size:20px;font-weight:700;}
  .sub{margin:0 0 10px 0;opacity:.8;}
  .row{display:flex;gap:14px;flex-wrap:wrap;align-items:flex-end;}
  .field{flex:1;min-width:280px;}
  input[type="text"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(0,0,0,.2);font-size:14px;}
  datalist option{font-size:14px;}
  .help{font-size:13px;opacity:.75;margin-top:8px;}
  .status{margin-top:10px;font-size:14px;}
  .status.error{color:#b91c1c;}
  .status.ok{color:#065f46;}
  .viz{margin-top:16px;}
  .viz.hidden{display:none;}
</style>
</head>

<body>
<div id="pp-header"></div>
<script>
  // Injection header commun
  fetch('/guide/partials/pp-header.html', { cache: 'no-store' })
    .then(r => r.ok ? r.text() : '')
    .then(t => { if(t) document.getElementById('pp-header').innerHTML = t; })
    .catch(() => {});
</script>
<div class="app">
  <div class="card">
    <div class="title">Répartition des travaux réglementés par diplôme en PACA</div>

    <div class="field-label">Choix du diplôme (autocomplétion)</div>
    <div class="search-row">
      <input id="diplomaInput" type="text" list="diplomaList" placeholder="Commencez à taper le libellé du diplôme…" />
      <datalist id="diplomaList"></datalist>
    </div>
    <div class="hint">Saisissez quelques lettres puis choisissez un diplôme dans la liste proposée.</div>
    <div id="emptyMessage">Aucun diplôme sélectionné pour l’instant.</div>
    <div id="errorMessage" class="error" style="display:none;"></div>

    <div id="chartSection" class="chart-section">
      <div class="export-bar">
        <button id="btnPng" class="btn">Exporter PNG</button>
        <button id="btnPdf" class="btn">Exporter PDF</button>
      </div>

      <!-- Zone à capturer -->
      <div id="exportArea">
        <div id="chartHeader" class="chart-header" style="margin-bottom:24px;"></div>
        <div class="chart-wrapper">
          <canvas id="pieCanvas"></canvas>
        </div>
        <div id="legend" style="margin-top:40px;"></div>
        <div id="equipmentSection" class="equipment-section"></div>
      </div>
    </div>
  </div>
</div>

<script>
  Chart.register(ChartDataLabels);

  // ============ CONSTANTES =============
  const DIPLOME_TABLE     = "Diplomes_EN_OK";
  const DIPLOME_LABEL_COL = "Concatenation";

  const EQUIPEMENTS_TABLE      = "Liste_des_equipements";
  const COL_EQ_TAMPON_DIPLOMES = "Tampon_Diplomes";
  const COL_EQ_TAMPON_TRAVAUX  = "Tampon_Travaux";
  const COL_EQ_TAMPON_INTIT    = "Tampon_intitule_travaux";  // ex: "22|red;31|orange"
  const COL_EQ_EQUIPEMENT      = "Equipements_ou_produits";
  const COL_EQ_COULEUR         = "Couleur";

  const TRAVAUX_TABLE    = "Liste_travaux";
  const COL_TRAV_LABEL   = "Travaux";
  const COL_TRAV_URL     = "Url_fiche";

  const GRIST_EQUIP_VIEW_URL =
    "https://docs.getgrist.com/gvPEJV3qAHS9/Equipements-de-travail-et-produits/p/119";
  // ====================================

  let diplomasByLabel = new Map();

  // { diplomaKeyNorm: Map(normTravail -> {label, regime}) }
  let travauxRegimeByDiplome = {};

  // { diplomaKeyNorm: Map(normTravail -> Set(equip labels)) }
  let travailEquipByDiplome = {};

  // { diplomaKeyNorm: {derog:[], interdit:[], autorise:[], non_classe:[]} }
  let equipmentsByDiplomeAndRegime = {};

  // URLs travaux
  let travailToUrl = new Map();           // libellé exact -> url
  let travailToUrlByNorm = new Map();     // libellé normalisé -> url

  let pieChart = null;
// ---------- utilitaires ----------
  function normalizeText(str) {
    if (str == null) return "";
    return String(str).normalize("NFD").replace(/[̀-ͯ]/g, "").toLowerCase().trim();
  }

  function splitItems(str) {
    if (str == null) return [];
    return String(str).split(/[;\n]/).map(s => s.trim()).filter(Boolean);
  }

  function showError(msg) {
    const err = document.getElementById("errorMessage");
    err.textContent = msg;
    err.style.display = "block";
  }

  function clearError() {
    const err = document.getElementById("errorMessage");
    err.style.display = "none";
  }

  function resetView(message) {
    const emptyMsg = document.getElementById("emptyMessage");
    const chartSection = document.getElementById("chartSection");
    emptyMsg.textContent = message || "Aucun diplôme sélectionné pour l’instant.";
    chartSection.style.display = "none";
    if (pieChart) {
      pieChart.destroy();
      pieChart = null;
    }
    document.getElementById("legend").innerHTML = "";
    document.getElementById("equipmentSection").innerHTML = "";
  }

  // ---------- régimes ----------
  function regimeFromColorCode(code) {
    if (!code) return "non_classe";
    const parts = String(code).split("|");
    const colorPart = parts[1] ? parts[1].trim() : "";
    const n = normalizeText(colorPart);
    if (n.includes("red") || n.includes("rouge"))   return "interdit";
    if (n.includes("orange"))                       return "derog";
    if (n.includes("green") || n.includes("vert"))  return "autorise";
    return "non_classe";
  }

  function regimeRank(reg) {
    if (reg === "interdit") return 3;
    if (reg === "derog") return 2;
    if (reg === "autorise") return 1;
    return 0;
  }

  function mergeRegime(existing, incoming) {
    if (!existing) return incoming;
    return (regimeRank(incoming) > regimeRank(existing)) ? incoming : existing;
  }

  function getUrlForTravail(label) {
    if (!label) return "";
    const direct = travailToUrl.get(String(label));
    if (direct) return direct;
    const n = normalizeText(label);
    return travailToUrlByNorm.get(n) || "";
  }

  // Palettes (13 oranges pour la dérogation)
  const ORANGE_SHADES_13 = [
    "#ffedd5","#fed7aa","#fdba74","#fb923c","#f97316","#ea580c","#c2410c",
    "#ffb366","#ffa24d","#ff8f33","#ff7b1a","#f26800","#d45500"
  ];
  const RED_SHADES_6    = ["#fecaca","#fca5a5","#f87171","#ef4444","#dc2626","#b91c1c"];
  const GREEN_SHADES_6  = ["#bbf7d0","#86efac","#4ade80","#22c55e","#16a34a","#15803d"];

  function regimeColor(regime, idxInRegime) {
    if (regime === "interdit") return RED_SHADES_6[idxInRegime % RED_SHADES_6.length];
    if (regime === "autorise") return GREEN_SHADES_6[idxInRegime % GREEN_SHADES_6.length];
    if (regime === "derog")    return ORANGE_SHADES_13[idxInRegime % ORANGE_SHADES_13.length];
    return "#9ca3af";
  }

  function regimeLabel(regime) {
    if (regime === "interdit") return "interdit absolument";
    if (regime === "derog") return "soumis à dérogation";
    if (regime === "autorise") return "autorisé";
    return "non encore classé";
  }

  // ---------- Labels : 2 lignes (compatibles datalabels) ----------
  function splitLabelTwoLines(label) {
    const s = String(label || "").trim().replace(/\s+/g, " ");
    if (!s) return ["", ""];
    const words = s.split(" ");
    if (words.length <= 3) return [s, ""];
    const mid = Math.ceil(words.length / 2);
    return [words.slice(0, mid).join(" "), words.slice(mid).join(" ")];
  }

  function wrapText(s, maxLen) {
    const str = String(s || "").trim().replace(/\s+/g, " ");
    if (str.length <= maxLen) return str;
    return str.slice(0, Math.max(0, maxLen - 1)) + "…";
  }

  function labelOutsideLines(travailLabel) {
    const [l1, l2] = splitLabelTwoLines(travailLabel);
    return [wrapText(l1, 46), wrapText(l2, 46)].filter(Boolean);
  }

  // ---------- chargement initial ----------
  function recordsToColumns(records) {
    const ids = [];
    const cols = { id: ids };
    const keys = new Set();
    for (const r of (records || [])) {
      ids.push(r?.id ?? null);
      const f = r?.fields || {};
      for (const k of Object.keys(f)) keys.add(k);
    }
    for (const k of keys) cols[k] = new Array(ids.length).fill(null);
    let i = 0;
    for (const r of (records || [])) {
      const f = r?.fields || {};
      for (const k of keys) cols[k][i] = (k in f) ? f[k] : null;
      i++;
    }
    return cols;
  }

  function normalizeTable(raw) {
    if (!raw) return null;

    // Déjà au format colonnes (fetchTable Grist)
    if (raw.id && Array.isArray(raw.id)) return raw;

    // Si on reçoit directement un tableau [{id, fields}...] (cas où un wrapper renvoie records)
    if (Array.isArray(raw)) return recordsToColumns(raw);

    // read-app: {records:[{id,fields}...]}
    if (Array.isArray(raw.records)) return recordsToColumns(raw.records);

    // read-app Liste_des_equipements: parfois {items:[...], records:[...]}
    if (Array.isArray(raw.items) && Array.isArray(raw.records)) return recordsToColumns(raw.records);

    // Fallback: rien de lisible
    return null;
  }
  async function init() {
    try {
if (!window.PP_fetchTable) {
  showError("PP_fetchTable indisponible (pp-config/PP_SB_API_READ non disponible).");
  return;
}
const fetchT = async (name) => normalizeTable(await window.PP_fetchTable(name));

      const [diplomeTable, equipTable, travauxTable] = await Promise.all([
        fetchT(DIPLOME_TABLE),
        fetchT(EQUIPEMENTS_TABLE),
        fetchT(TRAVAUX_TABLE)
      ]);

      if (!diplomeTable || !equipTable || !travauxTable) {
        showError("Erreur lors du chargement des données (tables incomplètes).");
        return;
      }

      buildDiplomas(diplomeTable);
      buildTravailUrls(travauxTable);
      buildTravauxAndEquipByDiplome(equipTable);
      populateDiplomaDatalist();
      wireExportButtons();
    } catch (e) {
      console.error(e);
      showError("Erreur lors du chargement des données : " + (e?.message || e));
    }
  }


  function buildDiplomas(table) {
    diplomasByLabel.clear();
    if (!table || !table.id) return;

    const labels = table[DIPLOME_LABEL_COL] || [];
    (table.id || []).forEach((id, idx) => {
      const label = labels[idx];
      if (label) diplomasByLabel.set(String(label), id);
    });
  }

  function buildTravailUrls(table) {
    travailToUrl.clear();
    travailToUrlByNorm.clear();
    if (!table || !table.id) return;

    const labels = table[COL_TRAV_LABEL] || [];
    const urls = table[COL_TRAV_URL] || [];
    const n = table.id.length;

    for (let i = 0; i < n; i++) {
      const label = labels[i];
      if (!label) continue;
      const url = urls[i] || "";
      const key = String(label);

      travailToUrl.set(key, url);
      const norm = normalizeText(key);
      if (!travailToUrlByNorm.has(norm)) travailToUrlByNorm.set(norm, url);
    }
  }

  function ensureDiplomaStores(dKey) {
    if (!travauxRegimeByDiplome[dKey]) travauxRegimeByDiplome[dKey] = new Map();
    if (!travailEquipByDiplome[dKey]) travailEquipByDiplome[dKey] = new Map();
    if (!equipmentsByDiplomeAndRegime[dKey]) {
      equipmentsByDiplomeAndRegime[dKey] = { derog: [], interdit: [], autorise: [], non_classe: [] };
    }
  }

  function buildTravauxAndEquipByDiplome(table) {
    travauxRegimeByDiplome = {};
    travailEquipByDiplome = {};
    equipmentsByDiplomeAndRegime = {};
    if (!table || !table.id) return;

    const diplTextCol   = table[COL_EQ_TAMPON_DIPLOMES] || [];
    const travNamesCol  = table[COL_EQ_TAMPON_TRAVAUX]  || [];
    const travCodesCol  = table[COL_EQ_TAMPON_INTIT]    || [];
    const equipCol      = table[COL_EQ_EQUIPEMENT]      || [];
    const colorCol      = table[COL_EQ_COULEUR]         || [];
    const ids           = table.id || [];
    const n = ids.length;

    for (let i = 0; i < n; i++) {
      const diplStr      = diplTextCol[i];
      const travNamesStr = travNamesCol[i];
      const travCodesStr = travCodesCol[i];
      if (!diplStr || !travNamesStr) continue;

      const diplomes  = splitItems(diplStr);
      const travaux   = splitItems(travNamesStr);
      const travCodes = splitItems(travCodesStr);

      if (!diplomes.length || !travaux.length) continue;

      const equipLabel  = String(equipCol[i] || "").trim();
      const equipColor  = colorCol[i];
      const rowId       = ids[i];

      diplomes.forEach(d => {
        const dKey = normalizeText(d);
        if (!dKey) return;
        ensureDiplomaStores(dKey);

        const maxLen = Math.max(travaux.length, travCodes.length);
        for (let idx = 0; idx < maxLen; idx++) {
          const travailLabel = travaux[idx] || travaux[travaux.length - 1];
          if (!travailLabel) continue;

          const tNorm = normalizeText(travailLabel);

          let regime = "non_classe";
          const code = travCodes[idx];
          if (code) regime = regimeFromColorCode(code);

          const existing = travauxRegimeByDiplome[dKey].get(tNorm);
          const merged = existing
            ? { label: existing.label || travailLabel, regime: mergeRegime(existing.regime, regime) }
            : { label: travailLabel, regime: regime };
          travauxRegimeByDiplome[dKey].set(tNorm, merged);

          if (!travailEquipByDiplome[dKey].has(tNorm)) {
            travailEquipByDiplome[dKey].set(tNorm, new Set());
          }
          if (equipLabel) travailEquipByDiplome[dKey].get(tNorm).add(equipLabel);

          const bucket = equipmentsByDiplomeAndRegime[dKey][regime] || equipmentsByDiplomeAndRegime[dKey].non_classe;
          bucket.push({ label: equipLabel, color: equipColor, rowId });
        }
      });
    }
  }

  function populateDiplomaDatalist() {
    const datalist = document.getElementById("diplomaList");
    datalist.innerHTML = "";
    const labels = Array.from(diplomasByLabel.keys()).filter(Boolean)
      .sort((a, b) => a.localeCompare(b, "fr", { sensitivity: "base" }));
    labels.forEach(label => {
      const opt = document.createElement("option");
      opt.value = label;
      datalist.appendChild(opt);
    });
  }

  const diplomaInput = document.getElementById("diplomaInput");
  diplomaInput.addEventListener("change", () => {
    clearError();
    const label = diplomaInput.value.trim();
    if (!label) {
      resetView("Aucun diplôme sélectionné pour l’instant.");
      return;
    }
    updateForDiploma(label);
  });

  function getBestKeyMatch(targetKeyNorm, sourceObj) {
    if (sourceObj[targetKeyNorm]) return targetKeyNorm;
    const keys = Object.keys(sourceObj);
    for (const k of keys) {
      if (k && (k.includes(targetKeyNorm) || targetKeyNorm.includes(k))) return k;
    }
    return null;
  }

  function updateForDiploma(diplomaLabel) {
    const keyNorm = normalizeText(diplomaLabel);
    const emptyMsg     = document.getElementById("emptyMessage");
    const chartSection = document.getElementById("chartSection");

    if (!keyNorm) {
      resetView("Aucun diplôme sélectionné pour l’instant.");
      return;
    }

    const mapKeyTrav  = getBestKeyMatch(keyNorm, travauxRegimeByDiplome);
    const mapKeyEquip = getBestKeyMatch(keyNorm, travailEquipByDiplome);

    const travailMap = mapKeyTrav ? travauxRegimeByDiplome[mapKeyTrav] : null;
    const equipMap   = mapKeyEquip ? travailEquipByDiplome[mapKeyEquip] : null;

    if (!travailMap || !equipMap || travailMap.size === 0) {
      resetView("Aucun travail réglementé trouvé pour ce diplôme.");
      return;
    }

    const pieItems = [];
    for (const [tNorm, meta] of travailMap.entries()) {
      const regime = (meta && meta.regime) ? meta.regime : "non_classe";
      if (regime === "non_classe") continue;

      const label = (meta && meta.label) ? meta.label : tNorm;
      const set = equipMap.get(tNorm);
      const equips = set ? Array.from(set).sort((a,b) => a.localeCompare(b, "fr")) : [];
      if (!equips.length) continue;

      pieItems.push({ norm:tNorm, label, regime, equipments: equips, value: equips.length });
    }

    if (!pieItems.length) {
      resetView("Aucun travail classé (dérogation / interdit / autorisé) avec équipements associés. Les éléments non classés ne sont pas affichés dans le camembert.");
      return;
    }

    const regimeOrder = { interdit: 0, derog: 1, autorise: 2 };
    pieItems.sort((a, b) => {
      const ra = regimeOrder[a.regime] ?? 9;
      const rb = regimeOrder[b.regime] ?? 9;
      if (ra !== rb) return ra - rb;
      return a.label.localeCompare(b.label, "fr");
    });

    const counters = { interdit: 0, derog: 0, autorise: 0 };
    pieItems.forEach(it => {
      const idx = counters[it.regime] || 0;
      it.color = regimeColor(it.regime, idx);
      counters[it.regime] = idx + 1;
    });

    emptyMsg.textContent = "";
    chartSection.style.display = "block";

    document.getElementById("chartHeader").textContent =
      "Répartition par travaux (éléments non classés exclus) pour : " + diplomaLabel;

    const values = pieItems.map(x => x.value);
    const total = values.reduce((a, b) => a + b, 0);
    const labels = pieItems.map(x => x.label);
    const colors = pieItems.map(x => x.color);

    const ctx = document.getElementById("pieCanvas").getContext("2d");
    if (pieChart) { pieChart.destroy(); pieChart = null; }

    pieChart = new Chart(ctx, {
      type: "pie",
      data: {
        labels,
        datasets: [{
          data: values,
          backgroundColor: colors,
          borderColor: "#ffffff",
          borderWidth: 1,
          radius: 170
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: { padding: { top: 60, right: 90, bottom: 60, left: 90 } },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: (items) => {
                const idx = items[0].dataIndex;
                const it = pieItems[idx];
                return `${it.label} (${regimeLabel(it.regime)})`;
              },
              label: (context) => {
                const idx = context.dataIndex;
                const it = pieItems[idx];
                const pct = total ? (it.value / total * 100) : 0;

                const lines = [];
                lines.push(`${it.value} équipement(s)/produit(s) — ${pct.toFixed(1)}%`);
                lines.push("Liste :");
                it.equipments.forEach(e => lines.push("• " + e));
                return lines;
              }
            }
          },
          datalabels: {
            labels: {
              outside: {
                color: "#111827",
                font: { size: 15, weight: "600" },
                anchor: "end",
                align: "end",
                offset: 18,
                lineHeight: 1.35,
                clamp: true,
                formatter: (value, context) => {
                  const idx = context.dataIndex;
                  const it = pieItems[idx];
                  return labelOutsideLines(it.label);
                }
              },
              inside: {
                color: "#000000",
                font: { size: 13, weight: "700" },
                anchor: "center",
                align: "center",
                formatter: (value) => {
                  const pct = total ? (value / total * 100) : 0;
                  return pct ? (pct.toFixed(1) + "%") : "";
                }
              }
            }
          }
        }
      }
    });

    buildLegendByRegimeFromMap(mapKeyTrav);
    buildEquipmentList(getBestKeyMatch(keyNorm, equipmentsByDiplomeAndRegime) || keyNorm);
  }

  function buildLegendByRegimeFromMap(mapKey) {
    const legendDiv = document.getElementById("legend");
    legendDiv.innerHTML = "";

    const groups = { interdit: [], derog: [], autorise: [], non_classe: [] };
    const travailMap = mapKey ? travauxRegimeByDiplome[mapKey] : null;

    if (travailMap && travailMap.size) {
      const mergedByNorm = new Map();
      for (const [tNorm, obj] of travailMap.entries()) {
        const label = obj.label;
        const regime = obj.regime || "non_classe";
        const prev = mergedByNorm.get(tNorm);
        if (!prev) mergedByNorm.set(tNorm, { label, regime });
        else mergedByNorm.set(tNorm, { label: prev.label || label, regime: mergeRegime(prev.regime, regime) });
      }

      const items = Array.from(mergedByNorm.values())
        .filter(x => x.label)
        .sort((a, b) => a.label.localeCompare(b.label, "fr"));

      items.forEach(x => {
        groups[x.regime || "non_classe"].push({
          label: x.label,
          regime: x.regime || "non_classe",
          url: getUrlForTravail(x.label)
        });
      });
    }

    const columnsContainer = document.createElement("div");
    columnsContainer.className = "legend-columns";

    function buildColumn(title, items, colorSample) {
      const col = document.createElement("div");
      col.className = "legend-column";

      const titleEl = document.createElement("div");
      titleEl.className = "legend-column-title";
      titleEl.textContent = title;
      if (colorSample) titleEl.style.color = colorSample;
      col.appendChild(titleEl);

      const list = document.createElement("div");
      list.className = "legend-list";

      const visibleItems = items.filter(x => x.regime !== "non_classe");

      if (!visibleItems.length) {
        const empty = document.createElement("div");
        empty.style.fontSize = "0.8rem";
        empty.style.color = "#9ca3af";
        empty.textContent = "— Aucun travail —";
        list.appendChild(empty);
      } else {
        visibleItems.forEach(w => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const colorBox = document.createElement("span");
          colorBox.className = "legend-color";
          colorBox.style.backgroundColor = (w.regime === "derog") ? "#f97316" : (w.regime === "interdit") ? "#dc2626" : "#16a34a";

          const link = document.createElement("a");
          link.className = "legend-link";
          link.textContent = w.label;

          if (w.url) {
            link.href = w.url;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
          } else {
            link.classList.add("no-link");
            link.title = "Aucun lien de fiche disponible";
          }

          item.appendChild(colorBox);
          item.appendChild(link);
          list.appendChild(item);
        });
      }

      col.appendChild(list);
      return col;
    }

    columnsContainer.appendChild(buildColumn("Travaux interdits absolument", groups.interdit, "#dc2626"));
    columnsContainer.appendChild(buildColumn("Travaux soumis à dérogation", groups.derog, "#f97316"));
    columnsContainer.appendChild(buildColumn("Travaux autorisés", groups.autorise, "#16a34a"));

    legendDiv.appendChild(columnsContainer);
  }

  function colorForRegimeBox(regime) {
    if (regime === "interdit") return "#dc2626";
    if (regime === "derog")    return "#f97316";
    if (regime === "autorise") return "#16a34a";
    return "#9ca3af";
  }

  function buildEquipmentList(diplomaKeyNorm) {
    const section = document.getElementById("equipmentSection");
    section.innerHTML = "";

    const agg = { derog: [], interdit: [], autorise: [], non_classe: [] };

    function addFromKey(k) {
      const cats = equipmentsByDiplomeAndRegime[k];
      if (!cats) return;
      ["derog","interdit","autorise","non_classe"].forEach(cat => {
        if (!cats[cat]) return;
        agg[cat] = agg[cat].concat(cats[cat]);
      });
    }

    addFromKey(diplomaKeyNorm);

    if (!agg.derog.length && !agg.interdit.length && !agg.autorise.length && !agg.non_classe.length) {
      Object.keys(equipmentsByDiplomeAndRegime).forEach(k => {
        if (k.includes(diplomaKeyNorm) || diplomaKeyNorm.includes(k)) addFromKey(k);
      });
    }

    if (!agg.derog.length && !agg.interdit.length && !agg.autorise.length && !agg.non_classe.length) {
      section.textContent = "Aucun équipement ou produit associé trouvé dans la table des équipements.";
      return;
    }

    function dedup(list) {
      const map = new Map();
      list.forEach(e => {
        const label = e.label || "";
        const rowId = e.rowId || "";
        if (!label) return;
        const key = label + "|" + rowId;
        if (!map.has(key)) map.set(key, e);
      });
      return Array.from(map.values()).sort((a, b) => a.label.localeCompare(b.label, "fr"));
    }

    const derogList    = dedup(agg.derog);
    const interditList = dedup(agg.interdit);
    const autorList    = dedup(agg.autorise);
    const nonClassList = dedup(agg.non_classe);

    const title = document.createElement("div");
    title.className = "equipment-title";
    title.textContent = "Équipements ou produits associés au diplôme (classés selon le régime d’interdiction) :";
    section.appendChild(title);

    const columnsDiv = document.createElement("div");
    columnsDiv.className = "equip-columns";

    function buildEquipColumn(titleText, list, regimeKey) {
      const col = document.createElement("div");
      col.className = "equip-column";

      const h = document.createElement("div");
      h.className = "equip-column-title";
      h.textContent = titleText;
      h.style.color = colorForRegimeBox(regimeKey);
      col.appendChild(h);

      const listDiv = document.createElement("div");
      listDiv.className = "equip-list";

      if (!list.length) {
        const msg = document.createElement("div");
        msg.className = "equip-empty";
        msg.textContent = "— Aucun équipement —";
        listDiv.appendChild(msg);
      } else {
        list.forEach(e => {
          const item = document.createElement("div");
          item.className = "equip-item";

          const box = document.createElement("span");
          box.className = "equip-color";
          box.style.backgroundColor = colorForRegimeBox(regimeKey);

          const link = document.createElement("a");
          link.className = "equip-link";
          link.textContent = e.label;
          if (e.rowId != null) {
            link.href = GRIST_EQUIP_VIEW_URL + "?rowId=" + encodeURIComponent(e.rowId);
            link.target = "_blank";
            link.rel = "noopener noreferrer";
          }

          item.appendChild(box);
          item.appendChild(link);
          listDiv.appendChild(item);
        });
      }

      col.appendChild(listDiv);
      return col;
    }

    columnsDiv.appendChild(buildEquipColumn("soumis à dérogation", derogList, "derog"));
    columnsDiv.appendChild(buildEquipColumn("interdit absolument", interditList, "interdit"));
    columnsDiv.appendChild(buildEquipColumn("autorisé", autorList, "autorise"));
    columnsDiv.appendChild(buildEquipColumn("non encore classé", nonClassList, "non_classe"));

    section.appendChild(columnsDiv);
  }

  function wireExportButtons() {
    const btnPng = document.getElementById("btnPng");
    const btnPdf = document.getElementById("btnPdf");
    if (!btnPng || !btnPdf) return;

    btnPng.addEventListener("click", () => exportImage("png"));
    btnPdf.addEventListener("click", () => exportImage("pdf"));
  }

  async function exportImage(mode) {
    const btnPng = document.getElementById("btnPng");
    const btnPdf = document.getElementById("btnPdf");
    const exportArea = document.getElementById("exportArea");
    if (!exportArea) return;

    btnPng.disabled = true;
    btnPdf.disabled = true;

    document.body.classList.add("exporting");
    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

    const canvas = await html2canvas(exportArea, {
      backgroundColor: "#ffffff",
      scale: 2,
      useCORS: true
    });

    const dataUrl = canvas.toDataURL("image/png");

    if (mode === "png") {
      downloadDataUrl(dataUrl, "repartition_travaux.png");
    } else {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });

      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();

      const imgW = pageW - 60;
      const imgH = canvas.height * (imgW / canvas.width);

      if (imgH <= pageH - 60) {
        pdf.addImage(dataUrl, "PNG", 30, 30, imgW, imgH);
      } else {
        const scaledH = pageH - 60;
        const scaledW = canvas.width * (scaledH / canvas.height);
        const x = (pageW - scaledW) / 2;
        pdf.addImage(dataUrl, "PNG", x, 30, scaledW, scaledH);
      }

      pdf.save("repartition_travaux.pdf");
    }

    document.body.classList.remove("exporting");
    btnPng.disabled = false;
    btnPdf.disabled = false;
  }

  function downloadDataUrl(dataUrl, filename) {
    const a = document.createElement("a");
    a.href = dataUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  init();
</script>
  <script src="https://preventionpaca.github.io/guide/js/pp-header.js"></script>
</body>
</html>
