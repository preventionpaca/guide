<!DOCTYPE html>
<html lang="fr">
<head>
  
  <script>
    // ‚úÖ CORRECTION : D√©finir le bon nom d'app
    window.PP_APP_NAME = "equipements";
  </script>
<meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Avis m√©dical ‚Äì Travaux r√©glement√©s</title>

  <!-- API GRIST -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  
  <!-- ‚úÖ Data Layer Supabase (identique √† ddfpt.html) -->
  <script>
    (function(){
  const DEFAULT_SB = "https://hpiqwvwpxzppxpxhjede.supabase.co";
  const sbBase = (window.PP_SUPABASE_URL || DEFAULT_SB).replace(/\/+$/,'');
  const SB_ROOT = sbBase + "/functions/v1";
  window.PP_SB_ROOT = SB_ROOT;
  window.PP_SB_API_READ  = SB_ROOT + "/read-app";
  window.PP_SB_API_AUTH  = SB_ROOT + "/auth-code";
  window.PP_SB_API_WRITE = SB_ROOT + "/write-app";
  
  function getAppName(){
    return (window.PP_APP_DEFAULT || window.PP_APP_NAME || "equipements");
  }
  
  window.PP_IS_GRIST = !!(window.grist && window.grist.docApi && typeof window.grist.docApi.fetchTable === 'function' && window.parent !== window);

  function rowsToGristTable(rows){
    if(!Array.isArray(rows) || !rows.length) return {id:[]};
    const cols = new Set();
    for(const r of rows) Object.keys(r||{}).forEach(k=>cols.add(k));
    cols.delete('id');
    const t={id:[]};
    for(const c of cols) t[c]=[];
    for(const r of rows){
      t.id.push(r.id);
      for(const c of cols) t[c].push(r[c]);
    }
    return t;
  }

  async function sbFetchTable(tableName){
    const url1 = window.PP_SB_API_READ + "?app=" + encodeURIComponent(getAppName()) + "&table=" + encodeURIComponent(tableName);
    let r = await fetch(url1, {credentials:'omit'});
    let j = await r.json().catch(()=>null);
    if(j && j.ok){
      if (Array.isArray(j.records)) {
        const rows = j.records.map(r => ({ id: r.id, ...(r.fields || {}) }));
        return rowsToGristTable(rows);
      }
      if(j.table) return j.table;
      if(Array.isArray(j.rows)) return rowsToGristTable(j.rows);
      if(Array.isArray(j.data)) return rowsToGristTable(j.data);
      if(j.items && Array.isArray(j.items)) return rowsToGristTable(j.items);
      if(j.tables && j.tables[tableName]) return j.tables[tableName];
      return j;
    }
    const url2 = window.PP_SB_API_READ + "?app=" + encodeURIComponent(getAppName());
    r = await fetch(url2, {credentials:'omit'});
    j = await r.json().catch(()=>null);
    if(j && j.ok && j.tables && j.tables[tableName]) return j.tables[tableName];
    throw new Error(j?.error || "Lecture Supabase impossible");
  }

  window.PP_fetchTable = async function(tableName){
    if(window.PP_IS_GRIST) return window.grist.docApi.fetchTable(tableName);
    return sbFetchTable(tableName);
  };
  
  // ‚úÖ Shim pour compatibilit√©
  if (!window.PP_IS_GRIST) {
    window.grist = window.grist || {};
    window.grist.docApi = window.grist.docApi || {};
    window.grist.docApi.fetchTable = window.PP_fetchTable;

    if (typeof window.grist.rowsToRecords !== "function") {
      window.grist.rowsToRecords = function (table) {
        const ids = table.id || [];
        const records = [];
        let cols = {};

        if (table.fields && typeof table.fields === "object") cols = table.fields;
        else {
          for (const [k, v] of Object.entries(table)) {
            if (k === "id") continue;
            if (Array.isArray(v)) cols[k] = v;
          }
        }

        for (let i = 0; i < ids.length; i++) {
          const rec = { id: ids[i] };
          for (const [k, arr] of Object.entries(cols)) rec[k] = arr[i];
          records.push(rec);
        }
        return records;
      };
    }
  }
})();
</script>

<link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-core.css">
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-portail.css">
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-core.css" />
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-avis.css" />

  <style>
    /* ===== IMPRESSION : FORCER UN VERSO (PAGE 2) ===== */
    @media print {
      .page-break {
        break-before: page;
        page-break-before: always;
      }
    }

    /* ===== VERSO ===== */
    .verso {
      margin-top: 10px;
      font-size: 11px;
      line-height: 1.18;
    }
    .verso h2 {
      margin: 0 0 6px;
      font-size: 14px;
      letter-spacing: .2px;
    }
    .verso-meta {
      font-size: 11px;
      color: #111827;
      margin: 0 0 8px;
      padding: 6px 8px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #f8fafc;
    }
    .verso-meta strong { color: #0b2238; }
    .trav-card {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 6px 8px;
      margin: 6px 0;
      background: #ffffff;
      page-break-inside: avoid;
    }
    .trav-title {
      font-weight: 700;
      margin-bottom: 4px;
      color: #0b2238;
      font-size: 12px;
    }
    .equip-list {
      list-style-type: disc;
      margin: 0;
      padding-left: 16px;
    }
    .equip-list li {
      margin: 0;
      padding: 0;
      line-height: 1.15;
    }
    .equip-list.two-cols {
      column-count: 2;
      column-gap: 18px;
    }
    .equip-empty {
      margin: 0;
      color: #6b7280;
      font-size: 11px;
    }
    .doc-edited {
      margin-top: 14px;
      font-size: 12px;
      color: #374151;
      text-align: right;
    }
  </style>
</head>

<body>
<div class="page-wrap">

  <!-- ===== CONTENU AVIS M√âDICAL ===== -->
  <main class="pp-main">

    <div id="header-container"></div>
    <div class="wrapper">

      <!-- RECHERCHE (dipl√¥me + √©tablissement) ‚Äì non imprim√©e -->
      <div class="search-card non-printable">
        <h3>Recherche</h3>
        <p>
          1. Choisissez une <strong>formation</strong> (dipl√¥me).<br>
          2. Ces choix alimentent automatiquement le formulaire ci-dessous.
        </p>

        <div class="field-block">
          <label for="diplome-input">Recherche de dipl√¥me</label>
          <input
            id="diplome-input"
            class="search-input"
            type="text"
            placeholder="Ex. : Bac pro syst√®mes num√©riques‚Ä¶"
            autocomplete="off"
          />
          <div id="diplome-dropdown" class="dropdown"></div>
        </div>
      </div>

      <!-- EN-T√äTE AVIS M√âDICAL -->
      <table class="header-table" style="width: 100%; margin-bottom: 4px;">
        <tr>
          <td style="width: 30%;">
            <img src="https://static.wixstatic.com/media/b708d4_8534e9250eab4f72aa6294d167e58a23~mv2.png/v1/fill/w_600,h_385,al_c,q_85,usm_1.20_1.00_0.01,enc_auto/b708d4_8534e9250eab4f72aa6294d167e58a23~mv2.png"
                 alt="logo" style="width: 160px; height: auto;" />
          </td>
          <td>
            <h2>AVIS M√âDICAL D'APTITUDE AUX TRAVAUX R√âGLEMENT√âS</h2>
            <p class="header-subtitle">pour les jeunes √¢g√©s de 15 √† 18 ans</p>
          </td>
        </tr>
      </table>

      <!-- ETABLISSEMENT + R√âF√âRENCES JURIDIQUES -->
      <div class="header-info-row">
        <div id="etab-text" class="etab-text">
          <!-- Contenu rempli dynamiquement -->
        </div>
        <div class="legal-box">
          <ul>
            <li>D√©cret n¬∞2015-443 du 17 avril 2015 relatif √† la proc√©dure de d√©rogation pr√©vue √† l'article L4153-9 du code du travail.</li>
            <li>D√©cret n¬∞2013-915 du 11 octobre 2013 relatif aux travaux interdits et r√©glement√©s pour les jeunes de moins de 18 ans.</li>
            <li>D√©cret n¬∞2015-444 du 17 avril 2015 modifiant les articles D 4153-30 et D 4153-31 du code du travail.</li>
            <li>Instruction interminist√©rielle n¬∞2016-273 du 7 septembre 2016.</li>
          </ul>
        </div>
      </div>

      <hr style="margin-top: 15px;"/>

      <!-- IDENTIT√â DU JEUNE + FORMATION -->
      <table style="width: 100%; margin-bottom: 10px;">
        <tr>
          <td><strong>Nom :</strong></td>
          <td><input type="text" class="field"></td>
        </tr>
        <tr>
          <td><strong>Pr√©nom :</strong></td>
          <td><input type="text" class="field"></td>
        </tr>
        <tr>
          <td><strong>Date de naissance :</strong></td>
          <td><input type="text" placeholder="JJ/MM/AAAA" class="field"></td>
        </tr>
        <tr>
          <td><strong>Formation :</strong></td>
          <td>
            <div class="field">
              <strong><span id="formation-text"></span></strong>
            </div>
          </td>
        </tr>
      </table>

      <!-- TRAVAUX R√âGLEMENT√âS -->
      <h3 style="margin-top: 20px;"><u>Liste des travaux r√©glement√©s :</u></h3>
      <ul id="travaux-list"></ul>

      <!-- AVIS M√âDICAL + DATE + CACHETS -->
      <div class="avoid-break">
        <div class="avis-header">
          <h3 class="avis-title"><u>Avis m√©dical</u></h3>

          <div class="avis-date">
            <strong>Date :</strong>
            <span class="tat-wrapper">
              <input id="tat-input" type="text" class="tat-input" placeholder="JJ/MM/AAAA">
              <button
                type="button"
                id="tat-today-btn"
                class="tat-btn non-printable"
                title="Ins√©rer la date du jour"
              >
                üìÖ
              </button>
            </span>
          </div>
        </div>

        <form class="avis-medical-container">
          <input type="radio" id="avis1" name="avis_medical">
          <input type="radio" id="avis2" name="avis_medical">
          <input type="radio" id="avis3" name="avis_medical">

          <div class="avis-choix">
            <label for="avis1">Aptitude avec r√©serves</label>
            <label for="avis2">Inaptitude</label>
            <label for="avis3">Aptitude sans r√©serve</label>
          </div>

          <div class="avis1">
            <div class="avis-bloc">
              <label><strong>Aptitude avec r√©serves :</strong></label>
              <input type="text" placeholder="D√©tail des r√©serves">
            </div>
          </div>

          <div class="avis2">
            <div class="avis-bloc">
              <label><strong>Inaptitude :</strong></label>
              <input type="text" placeholder="Motif d'inaptitude">
            </div>
          </div>

          <div class="avis3">
            <div class="avis-bloc">
              <label><strong>Aptitude sans r√©serve</strong></label>
            </div>
          </div>

          <div class="non-printable" style="margin-top: 10px;">
            <button type="reset" style="padding: 6px 12px; font-size: 14px; cursor: pointer;">
              R√©initialiser
            </button>
          </div>
        </form>

        <!-- CACHETS -->
        <table class="cachets-table" style="width: 100%; font-size: 12px;">
          <tr>
            <td style="width: 48%;">
              <strong>Cachet + signature du m√©decin :</strong>
              <div style="border: 2px dashed #999; height: 110px; margin-top: 5px;"></div>
            </td>
            <td style="width: 4%;"></td>
            <td style="width: 48%;">
              <strong>Cachet + signature du Proviseur de l'√©tablissement :</strong>
              <div style="border: 2px dashed #999; height: 110px; margin-top: 5px;"></div>
            </td>
          </tr>
        </table>
      </div>

      <!-- BOUTON EXPORT PDF -->
      <div class="non-printable" style="text-align: right;">
        <button id="export-pdf-btn" class="export-btn">Exporter en PDF</button>
      </div>

      <!-- ===== VERSO (PAGE 2) ===== -->
      <div class="page-break"></div>
      <section class="verso">
        <h2>ANNEXE ‚Äì D√©tail des travaux r√©glement√©s et √©quipements associ√©s</h2>
        <div class="verso-meta">
          <div><strong>√âtablissement :</strong> <span id="verso-etab"></span></div>
          <div><strong>Formation :</strong> <span id="verso-formation"></span></div>
        </div>

        <div id="verso-content"></div>

        <div class="doc-edited">Document √©dit√© le <span id="doc-edited-date"></span></div>
      </section>

    </div>
  </main>
</div>

<!-- ===== SCRIPT PRINCIPAL ===== -->
<script>
  const COLUMN_CONCAT = "Concatenation";
  const TABLE_TRAVAUX = "Liste_des_equipements";
  const COL_TRAV_DIPLOME = "Tampon_Diplomes";
  const COL_TRAV_LIBELLE = "Tampon_Travaux";
  const COL_TRAV_CODES = "Tampon_intitule_travaux";
  const COL_TRAV_ETAB = "Tampon_Etab";
  const TABLE_ETAB = "Etablissements_edi";
  const HINT_ETAB_NOM = "appellation_officielle";
  const HINT_ETAB_ADR1 = "Adresse";
  const HINT_ETAB_CP = "Code_postal";
  const HINT_ETAB_VILLE = "Ville";
  const HINT_ETAB_MAIL = "email_etab";
  const HINT_ETAB_CODE = "Codepaca";
  const HINT_ETAB_DIPLOMES = "Diplomes";

  let allDiplomes = [];
  let travauxByDiplomeEtab = {};
  let equipByDiplomeEtabTrav = {};
  let etablissements = [];
  let auxTablesLoaded = false;
  let diplomaIdToLabel = {};
  let diplomeByEtabCode = {};
  let selectedEtabCodeNorm = null;
  let selectedEtabNameNorm = null;
  let selectedEtabNameLoose = null;
  let currentEtabName = "";

  const inputDiplome = document.getElementById("diplome-input");
  const dropDiplome = document.getElementById("diplome-dropdown");
  const formationText = document.getElementById("formation-text");
  const travauxListEl = document.getElementById("travaux-list");
  const versoEtabEl = document.getElementById("verso-etab");
  const versoFormEl = document.getElementById("verso-formation");
  const versoContentEl = document.getElementById("verso-content");
  const docEditedDateEl = document.getElementById("doc-edited-date");
  const etabText = document.getElementById("etab-text");

  function normalize(s) {
    if (!s) return "";
    let r = String(s).trim().toLowerCase();
    try { r = r.normalize("NFD").replace(/[\u0300-\u036f]/g, ""); } catch (e) {}
    r = r.replace(/[^a-z0-9]+/g, " ").replace(/\s+/g, " ").trim();
    return r;
  }

  function splitItems(txt) {
    if (!txt) return [];
    const s = String(txt).replace(/[\[\]]/g, " ");
    return s.split(/[;,|\/\n]+/).map(x => x.trim()).filter(Boolean);
  }

  function startsWithTravauxWord(s) {
    const n = normalize(s);
    return n.startsWith("travail") || n.startsWith("travaux");
  }

  function regimeFromColorCode(code) {
    if (!code) return "unknown";
    const c = String(code).toLowerCase();
    if (c.includes("31") || c.includes("orange")) return "derog";
    if (c.includes("21") || c.includes("vert")) return "autorise";
    if (c.includes("11") || c.includes("rouge") || c.includes("red")) return "interdit";
    return "unknown";
  }

  function formatTodayFR() {
    const d = new Date();
    const j = String(d.getDate()).padStart(2, "0");
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const a = d.getFullYear();
    return j + "/" + m + "/" + a;
  }

  function renderVerso() {
    const diplNorm = normalize(inputDiplome.value || "");
    if (!diplNorm || !selectedEtabNameNorm) {
      if (versoContentEl) versoContentEl.innerHTML = "";
      return;
    }

    if (versoFormEl) versoFormEl.textContent = inputDiplome.value || "";

    const byDipl = travauxByDiplomeEtab[diplNorm] || {};
    let travaux = [];
    if (byDipl[selectedEtabNameNorm]) {
      travaux = [...byDipl[selectedEtabNameNorm]];
    } else {
      const loose = String(selectedEtabNameNorm || "").replace(/[^a-z0-9]/g, "");
      for (const k of Object.keys(byDipl)) {
        if (String(k).replace(/[^a-z0-9]/g, "") === loose) {
          travaux = [...byDipl[k]];
          break;
        }
      }
    }

    travaux = travaux.map(t => String(t || "").trim()).filter(Boolean).filter(startsWithTravauxWord);
    if (!travaux.length) {
      if (versoContentEl) versoContentEl.innerHTML = "";
      return;
    }

    travaux.sort((a, b) => a.localeCompare(b, "fr"));

    let html = "";
    for (const trav of travaux) {
      const equipSet = (equipByDiplomeEtabTrav[diplNorm] || {})[selectedEtabNameNorm] || {};
      const items = equipSet[trav] || new Set();
      const arr = Array.from(items).filter(Boolean).sort((a, b) => a.localeCompare(b, "fr"));

      html += '<div class="trav-card">';
      html += '<div class="trav-title">' + trav + '</div>';

      if (arr.length) {
        const cls = arr.length > 10 ? "equip-list two-cols" : "equip-list";
        html += '<ul class="' + cls + '">';
        for (const eq of arr) html += '<li>' + eq + '</li>';
        html += '</ul>';
      } else {
        html += '<p class="equip-empty">Aucun √©quipement ou produit sp√©cifi√©.</p>';
      }

      html += '</div>';
    }
    if (versoContentEl) versoContentEl.innerHTML = html;
  }

  function tableToRows(table) {
    const ids = table.id || table.$id || [];
    const cols = {};
    for (const [k, v] of Object.entries(table)) {
      if (k === "id" || k === "$id") continue;
      if (Array.isArray(v)) cols[k] = v;
    }
    const rows = [];
    for (let i = 0; i < ids.length; i++) {
      const rec = { id: ids[i], fields: {} };
      for (const [k, arr] of Object.entries(cols)) rec.fields[k] = arr[i];
      rows.push(rec);
    }
    return rows;
  }

  async function fetchGristTableAny(tableName) {
    return await window.PP_fetchTable(tableName);
  }

  function guessColumn(keys, preferred, patterns) {
    if (!keys || !keys.length) return null;
    if (preferred && keys.includes(preferred)) return preferred;
    if (preferred) {
      const pLow = preferred.toLowerCase();
      const exact = keys.find(k => k.toLowerCase() === pLow);
      if (exact) return exact;
    }
    for (const pat of patterns) {
      const found = keys.find(k => k.toLowerCase().includes(pat));
      if (found) return found;
    }
    return null;
  }

  function getCurrentDiplomePool() {
    if (selectedEtabCodeNorm) {
      const set = diplomeByEtabCode[selectedEtabCodeNorm];
      if (set && set.size) return Array.from(set).sort((a, b) => a.localeCompare(b, "fr"));
    }
    return allDiplomes;
  }

  function buildDiplomeDropdown(query) {
    dropDiplome.innerHTML = "";
    const q = normalize(query);
    if (!q) { dropDiplome.style.display = "none"; return; }

    const pool = getCurrentDiplomePool();
    const matches = pool.filter(lbl => normalize(lbl).includes(q));
    if (!matches.length) { dropDiplome.style.display = "none"; return; }

    matches.slice(0, 40).forEach(lbl => {
      const item = document.createElement("div");
      item.className = "dropdown-item";
      item.textContent = lbl;
      item.addEventListener("mousedown", () => {
        inputDiplome.value = lbl;
        dropDiplome.style.display = "none";
        formationText.textContent = lbl;
        updateTravauxForDiplome(lbl);
      });
      dropDiplome.appendChild(item);
    });
    dropDiplome.style.display = "block";
  }

  inputDiplome.addEventListener("input", () => buildDiplomeDropdown(inputDiplome.value));
  inputDiplome.addEventListener("change", () => {
    const lbl = inputDiplome.value || "";
    formationText.textContent = lbl;
    updateTravauxForDiplome(lbl);
  });

  function keepOnlyTravailItems(label) {
    const n = normalize(label);
    return n.startsWith("travail") || n.startsWith("travaux");
  }

  function updateTravauxForDiplome(lbl) {
    const label = (lbl || "").trim();
    const q = normalize(label);
    travauxListEl.innerHTML = "";
    if (versoContentEl) versoContentEl.innerHTML = "";

    if (!label) return;

    // ‚úÖ R√©cup√©ration de l'√©tablissement depuis l'authentification centralis√©e
    const authState = window.PP_AUTH ? window.PP_AUTH.get() : null;
    if (!authState || !authState.codepaca) {
      console.warn("Aucune authentification : impossible de filtrer par √©tablissement");
      return;
    }

    selectedEtabCodeNorm = normalize(authState.codepaca);
    selectedEtabNameNorm = normalize(authState.etabName || "");
    selectedEtabNameLoose = String(selectedEtabNameNorm || "").replace(/[^a-z0-9]/g, "");
    currentEtabName = authState.etabName || "";

    if (versoEtabEl) versoEtabEl.textContent = currentEtabName;

    // Afficher les infos √©tablissement
    if (etabText) {
      etabText.innerHTML = `<strong>${authState.etabName || ""}</strong>`;
    }

    const byDipl = travauxByDiplomeEtab[q] || {};
    let travaux = [];
    if (byDipl[selectedEtabNameNorm]) {
      travaux = [...byDipl[selectedEtabNameNorm]];
    } else {
      const looseSel = String(selectedEtabNameNorm || "").replace(/[^a-z0-9]/g, "");
      for (const key of Object.keys(byDipl)) {
        if (String(key).replace(/[^a-z0-9]/g, "") === looseSel) {
          travaux = [...byDipl[key]];
          break;
        }
      }
    }

    if (!travaux.length) {
      const vus = new Set();
      for (const [k, arr] of Object.entries(byDipl)) {
        if (!k) continue;
        if (k.includes(q) || q.includes(k)) {
          for (const t of arr) {
            if (!vus.has(t)) {
              vus.add(t);
              travaux.push(t);
            }
          }
        }
      }
    }

    if (!travaux.length) return;

    travaux = travaux.map(t => String(t || "").trim()).filter(Boolean).filter(keepOnlyTravailItems);
    if (!travaux.length) return;

    travaux.sort((a, b) => a.localeCompare(b, "fr"));

    travaux.forEach(t => {
      const li = document.createElement("li");
      li.textContent = t;
      travauxListEl.appendChild(li);
    });

    renderVerso();
  }

  if (window.grist && typeof grist.ready === "function" && typeof grist.onRecords === "function") {
    grist.ready({ requiredAccess: 'full' });

    grist.onRecords(records => {
      const vals = [];
      diplomaIdToLabel = {};

      for (const rec of records) {
        const label = rec[COLUMN_CONCAT];
        if (label != null) vals.push(label);
        if (rec.id != null && label != null) diplomaIdToLabel[rec.id] = label;
      }

      allDiplomes = Array.from(new Set(vals.filter(Boolean))).sort((a, b) => a.localeCompare(b, "fr"));

      if (!auxTablesLoaded) {
        auxTablesLoaded = true;
        loadAuxTables();
      }
    });
  } else {
    if (!auxTablesLoaded) {
      auxTablesLoaded = true;
      setTimeout(() => loadAuxTables(), 300);
    }
  }

  async function loadAuxTables() {
    try {
      const [rawTravTable, rawEtabTable] = await Promise.all([
        fetchGristTableAny(TABLE_TRAVAUX),
        fetchGristTableAny(TABLE_ETAB)
      ]);

      const travRecs = tableToRows(rawTravTable);
      const etabRecs = tableToRows(rawEtabTable);

      if (travRecs.length) {
        const travSample = travRecs[0].fields || travRecs[0];
        const travKeys = Object.keys(travSample || {});

        const travColDiplome = guessColumn(travKeys, COL_TRAV_DIPLOME, ["diplome", "formation"]);
        const travColLib = guessColumn(travKeys, COL_TRAV_LIBELLE, ["tampon_travaux", "travaux", "travail", "intitul"]);
        const travColCodes = guessColumn(travKeys, COL_TRAV_CODES, ["tampon_intitule", "intitule_travaux", "travaux_code", "code", "couleur"]);
        const travColEquip = guessColumn(travKeys, null, ["appellation", "designation", "descript", "equip", "materiel", "mat√©riel", "produit", "machine", "outillage", "nom"]);
        const travColEtab = guessColumn(travKeys, COL_TRAV_ETAB, ["codepaca", "uai", "code_etab", "etab_code", "etablissement", "etab", "etablissements", "tampon_etab"]);

        if (travColDiplome && travColLib) {
          const tmp = {};

          for (const rec of travRecs) {
            const f = rec.fields || {};
            const diplText = f[travColDiplome];
            const libText = f[travColLib];
            const codesText = travColCodes ? f[travColCodes] : null;
            const equipText = travColEquip ? f[travColEquip] : null;
            const etabRaw = travColEtab ? f[travColEtab] : null;
            const etabKeys = splitItems(etabRaw).map(x => normalize(x)).filter(Boolean);

            if (!diplText || !libText) continue;
            if (!etabKeys.length) continue;

            const diplomesLigne = splitItems(diplText);
            const travauxLigne = splitItems(libText);
            const codesLigne = splitItems(codesText);

            if (!diplomesLigne.length || !travauxLigne.length) continue;

            const maxLen = Math.max(travauxLigne.length, codesLigne.length);

            diplomesLigne.forEach(oneDipl => {
              const key = normalize(oneDipl);
              if (!key) return;
              if (!tmp[key]) tmp[key] = {};

              etabKeys.forEach(etabKey => {
                if (!tmp[key][etabKey]) tmp[key][etabKey] = [];

                for (let idx = 0; idx < maxLen; idx++) {
                  const travailLabel = travauxLigne[idx] || travauxLigne[travauxLigne.length - 1];
                  if (!travailLabel) continue;

                  if (!startsWithTravauxWord(travailLabel)) continue;

                  const code = codesLigne[idx];
                  const regime = regimeFromColorCode(code);
                  if (regime !== "derog") continue;

                  tmp[key][etabKey].push(String(travailLabel).trim());

                  const eq = (equipText == null) ? "" : String(equipText).trim();
                  if (eq) {
                    if (!equipByDiplomeEtabTrav[key]) equipByDiplomeEtabTrav[key] = {};
                    if (!equipByDiplomeEtabTrav[key][etabKey]) equipByDiplomeEtabTrav[key][etabKey] = {};
                    if (!equipByDiplomeEtabTrav[key][etabKey][String(travailLabel).trim()]) {
                      equipByDiplomeEtabTrav[key][etabKey][String(travailLabel).trim()] = new Set();
                    }
                    equipByDiplomeEtabTrav[key][etabKey][String(travailLabel).trim()].add(eq);
                  }
                }
              });
            });
          }

          for (const dKey of Object.keys(tmp)) {
            const byEtab = tmp[dKey] || {};
            for (const eKey of Object.keys(byEtab)) {
              byEtab[eKey] = Array.from(new Set(byEtab[eKey])).sort((a, b) => a.localeCompare(b, "fr"));
            }
          }
          travauxByDiplomeEtab = tmp;
        }
      }

      if (etabRecs.length) {
        const sample = etabRecs[0].fields || etabRecs[0];
        const keys = Object.keys(sample || {});

        const colEtabNom = guessColumn(keys, HINT_ETAB_NOM, ["appel", "nom"]);
        const colEtabAdr1 = guessColumn(keys, HINT_ETAB_ADR1, ["adr", "adresse"]);
        const colEtabCP = guessColumn(keys, HINT_ETAB_CP, ["code_postal", "cp"]);
        const colEtabVille = guessColumn(keys, HINT_ETAB_VILLE, ["ville", "commune"]);
        const colEtabMail = guessColumn(keys, HINT_ETAB_MAIL, ["mail", "mel", "email", "courriel"]);
        const colEtabCode = guessColumn(keys, HINT_ETAB_CODE, ["codepaca", "uai", "code"]);
        const colEtabDiplomes = guessColumn(keys, HINT_ETAB_DIPLOMES, ["diplome"]);

        const etabs = [];
        diplomeByEtabCode = {};

        for (const rec of etabRecs) {
          const f = rec.fields || rec;
          const nom = colEtabNom ? (f[colEtabNom] || "") : "";
          const adr1 = colEtabAdr1 ? (f[colEtabAdr1] || "") : "";
          const cp = colEtabCP ? (f[colEtabCP] || "") : "";
          const ville = colEtabVille ? (f[colEtabVille] || "") : "";
          const mail = colEtabMail ? (f[colEtabMail] || "") : "";
          const code = colEtabCode ? (f[colEtabCode] || "") : "";
          const dipl = colEtabDiplomes ? (f[colEtabDiplomes] || "") : "";

          if (!nom) continue;

          const labelParts = [nom, ville || cp].filter(Boolean);
          const label = labelParts.join(" ‚Äì ");
          etabs.push({ label, nom, adresse: adr1, cp, ville, mail, code });

          const codeNorm = normalize(code);
          if (codeNorm && dipl) {
            const diplList = splitItems(dipl);
            if (diplList.length) {
              if (!diplomeByEtabCode[codeNorm]) diplomeByEtabCode[codeNorm] = new Set();
              diplList.forEach(dlbl => { if (dlbl) diplomeByEtabCode[codeNorm].add(dlbl); });
            }
          }
        }

        etabs.sort((a, b) => a.label.localeCompare(b, "fr"));
        etablissements = etabs;
      }

    } catch (e) {
      console.error(e);
    }
  }

  const tatInput = document.getElementById("tat-input");
  const tatBtn = document.getElementById("tat-today-btn");
  if (tatBtn && tatInput) {
    tatBtn.addEventListener("click", () => {
      const d = new Date();
      const jj = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const aa = d.getFullYear();
      tatInput.value = jj + "/" + mm + "/" + aa;
    });
  }

  const exportBtn = document.getElementById("export-pdf-btn");
  if (exportBtn) exportBtn.addEventListener("click", () => window.print());

  document.addEventListener("click", (evt) => {
    if (!dropDiplome.contains(evt.target) && evt.target !== inputDiplome) {
      dropDiplome.style.display = "none";
    }
  });

  window.addEventListener("load", () => {
    if (docEditedDateEl) docEditedDateEl.textContent = formatTodayFR();
  });

  // ‚úÖ Fonction appel√©e apr√®s authentification r√©ussie
  window.startPage = async function() {
    try {
      // R√©cup√©rer l'√©tat d'authentification
      const authState = window.PP_AUTH ? window.PP_AUTH.get() : null;
      if (authState && authState.etabName) {
        currentEtabName = authState.etabName;
        if (versoEtabEl) versoEtabEl.textContent = currentEtabName;
        if (etabText) etabText.innerHTML = `<strong>${currentEtabName}</strong>`;
      }
      
      // Charger les donn√©es si n√©cessaire
      if (!auxTablesLoaded) {
        auxTablesLoaded = true;
        await loadAuxTables();
      }
    } catch (e) {
      console.error("Erreur startPage:", e);
    }
  };
</script>

<!-- ‚úÖ Configuration + authentification centralis√©e -->
<script>
  window.PP_PAGE = 'ddfpt';
</script>
<script src="https://preventionpaca.github.io/guide/js/pp-config.js"></script>

<!-- ‚úÖ Verrou au d√©marrage + lancement startPage -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // Authentification DDFPT requise
      await window.PP_AUTH.requireDdfpt();

      // Une fois authentifi√©, lancer la page
      if (typeof window.startPage === 'function') {
        await window.startPage();
      }
    } catch (e) {
      console.error("Erreur auth:", e);
    }
  });
</script>

<script src="https://preventionpaca.github.io/guide/js/pp-header.js"></script>

</body>
</html>
