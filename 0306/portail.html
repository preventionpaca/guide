<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portail prévention PACA</title>

  <!-- CSS commun + CSS portail -->
  <link rel="stylesheet" href="../css/pp-core.css" />
  <link rel="stylesheet" href="../css/pp-portail.css" />
<script type="module">
import { isInGristWidget } from "../js/pp-runtime.js";
</script>
  <!-- Script Grist -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

<script>
  // ✅ Forcer l'app Supabase (même docId Grist : 4eHMq8g5jsqb)
  window.PP_APP_NAME = "equipements";
</script>

<script>
/* ==========================================================
   PP_DATA_LAYER (GitHub Pages + Grist)
   - Si la page est dans Grist: utilise grist.docApi.fetchTable/applyUserActions
   - Sinon: utilise Supabase Edge Functions (read-app/auth-code/write-app)
   ========================================================== */
(function(){
  const DEFAULT_SB = "https://hpiqwvwpxzppxpxhjede.supabase.co";
  const sbBase = (window.PP_SUPABASE_URL || DEFAULT_SB).replace(/\/+$/,'');
  const SB_ROOT = sbBase + "/functions/v1";
  window.PP_SB_ROOT = SB_ROOT;
  window.PP_SB_API_READ  = SB_ROOT + "/read-app";
  window.PP_SB_API_AUTH  = SB_ROOT + "/auth-code";
  window.PP_SB_API_WRITE = SB_ROOT + "/write-app";
  function getAppName(){
    return (window.PP_APP_DEFAULT || window.PP_APP_NAME || "equipements");
  }
window.PP_IS_GRIST = !!(window.grist && window.grist.docApi && typeof window.grist.docApi.fetchTable === 'function' && window.parent !== window);


  function rowsToGristTable(rows){
    if(!Array.isArray(rows) || !rows.length) return {id:[]};
    const cols = new Set();
    for(const r of rows) Object.keys(r||{}).forEach(k=>cols.add(k));
    cols.delete('id');
    const t={id:[]};
    for(const c of cols) t[c]=[];
    for(const r of rows){
      t.id.push(r.id);
      for(const c of cols) t[c].push(r[c]);
    }
    return t;
  }

  async function sbFetchTable(tableName){
    const url1 = window.PP_SB_API_READ + "?app=" + encodeURIComponent(getAppName()) + "&table=" + encodeURIComponent(tableName);
    let r = await fetch(url1, {credentials:'omit'});
    let j = await r.json().catch(()=>null);
    if(j && j.ok){
      // ✅ Support du format {records:[{id, fields:{...}}]}
      if (Array.isArray(j.records)) {
        const rows = j.records.map(r => ({ id: r.id, ...(r.fields || {}) }));
        return rowsToGristTable(rows);
      }
      if(j.table) return j.table;
      if(Array.isArray(j.rows)) return rowsToGristTable(j.rows);
      if(Array.isArray(j.data)) return rowsToGristTable(j.data);
      if(j.items && Array.isArray(j.items)) return rowsToGristTable(j.items);
      if(j.tables && j.tables[tableName]) return j.tables[tableName];
      return j;
    }
    const url2 = window.PP_SB_API_READ + "?app=" + encodeURIComponent(getAppName());
    r = await fetch(url2, {credentials:'omit'});
    j = await r.json().catch(()=>null);
    if(j && j.ok && j.tables && j.tables[tableName]) return j.tables[tableName];
    throw new Error(j?.error || "Lecture Supabase impossible");
  }

  window.PP_fetchTable = async function(tableName){
    if(window.PP_IS_GRIST) return window.grist.docApi.fetchTable(tableName);
    return sbFetchTable(tableName);
  };
})();
</script>


  <style>
    /* Ajout : bouton Tableau de bord poussé à gauche dans le footer de la card */
    .ppaca-card-footer {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .ppaca-btn-dashboard {
      margin-right: auto; /* pousse les autres boutons à droite */
    }
  </style>
</head>

<body>
<div class="page-wrap">

 <div id="header-container"></div>


  <!-- ===== CARTOUCHE PPP (texte d’intro) ===== -->
  <section class="ppaca-section">
    <div class="ppaca-card">
      <div class="ppaca-card-header">
        <div class="ppaca-avatar">PPP</div>
        <div>
          <h2 class="ppaca-card-title">Portail Prévention PACA – Accueil</h2>
          <p class="ppaca-card-subtitle"></p>
        </div>
      </div>

      <div class="ppaca-card-body">
        <p>
          Le portail Prévention PACA est la version numérique, enrichie
          et collaborative du Guide de prévention PACA.
          <strong>Guide de prévention</strong> co-édité par la DREETS PACA,
          la Région académique Provence–Alpes–Côte d’Azur avec le soutien du <a class="ppp-link-inline" href="https://forpro-paca.com/CFA-academie-Nice.html" target="_blank" rel="noopener">
  CFA académique de Nice
</a>.
        </p>

        <p>
          Il donne accès au guide, aux ressources de prévention, à la base régionale des équipements
          et travaux réglementés. Les directeurs délégués peuvent enrichir la base, associer leurs
          diplômes et générer le formulaire de demande de dérogation, des fiches de poste et des formulaires
          d’avis médicaux par diplôme.
        </p>

        <div class="ppaca-card-footer">

          <!-- ✅ NOUVEAU : Tableau de bord (aligné à gauche) -->
          <a
        href="https://preventionpaca.github.io/guide/0306/tableaubord.html"
            class="ppaca-btn-secondary ppaca-btn-secondary--ghost"
            target="_top" rel="noopener"
          >
            Tableau de bord
            
          </a>

          <!-- Boutons existants -->
          <a
           href="https://preventionpaca.github.io/guide/0306/savoirplus.html"
            class="ppaca-btn-secondary ppaca-btn-secondary--ghost"
            target="_top" rel="noopener"

          >
            En savoir plus
          </a>

          <a
            href="https://preventionpaca.github.io/guide/guide_iframe.html?src=https%3A%2F%2Fdocs.getgrist.com%2FgvPEJV3qAHS9%2FEquipements-de-travail-et-produits%2Fp%2F102%3Fembed%3Dtrue%26style%3DsinglePage%26exclude-headers%3Dtrue"
            class="ppaca-btn-secondary ppaca-btn-secondary--ghost"
            target="_top" rel="noopener"
          >
            Schéma fonctionnel
          </a>
        </div>
      </div>
    </div>
  </section>

  <!-- ===== CADRE ORANGE + TUILES ===== -->
  <section class="tile-frame">
    <main id="tileGrid" class="tile-grid"></main>
  </section>

</div>


<!-- ===== JS GRIST : UNIQUEMENT POUR LES TUILES ===== -->
<script>
  // Nom de la page dans la table Blocs
  const PAGE_NAME = 'Portail';


  // Racine du portail (index.html)
  const PORTAL_ROOT = 'https://preventionpaca.github.io/guide/';
  const ROUTES = {
    home: PORTAL_ROOT + '#home',
    base: PORTAL_ROOT + '#base',
    medicalStd: PORTAL_ROOT + '#medical',
    medicalCustom: PORTAL_ROOT + '#medical-custom'
  };

  // wrapper QR / deep-link (on conserve)
  const WRAPPER_BASE   = 'https://preventionpaca.github.io/guide/guide_iframe.html?src=';
  const WRAPPER_MARKER = 'guide_iframe.html';

  // mapping Grist -> route interne (pages cles)
  const GRIST_KEY_ROUTES = [
    { match: '/p/59',  to: ROUTES.home },
    { match: '/p/119', to: ROUTES.base },
    { match: '/p/67',  to: ROUTES.medicalStd },
    { match: '/p/141', to: ROUTES.medicalCustom }
  ];

  function rowsToRecordsCompat(table) {
    if (window.grist && typeof grist.rowsToRecords === 'function') {
      return grist.rowsToRecords(table);
    }
    const ids = table.id || [];
    const records = [];
    let columnArrays = {};

    if (table.fields && typeof table.fields === 'object') {
      columnArrays = table.fields;
    } else {
      for (const [key, value] of Object.entries(table)) {
        if (key === 'id') continue;
        if (Array.isArray(value)) columnArrays[key] = value;
      }
    }

    for (let i = 0; i < ids.length; i++) {
      const rec = { id: ids[i] };
      for (const [col, values] of Object.entries(columnArrays)) {
        rec[col] = values[i];
      }
      records.push(rec);
    }
    return records;
  }

  function normalizeName(v) {
    if (!v) return '';
    let s = String(v).trim().toLowerCase();
    try {
      s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    } catch (e) {}
    s = s.replace(/[_\s]+/g, ' ');
    s = s.replace(/\s+/g, ' ');
    return s;
  }

  function colorToClass(c) {
    if (!c) return '';
    const v = String(c).toLowerCase();
    if (v.includes('blanc'))        return 'tile--white';
    if (v.includes('vert'))         return 'tile--green';
    if (v.includes('orange'))       return 'tile--orange';
    if (v.includes('noir'))         return 'tile--dark';
    if (v.includes('marron clair')) return 'tile--brown-light';
    if (v.includes('marron fon'))   return 'tile--brown-dark';
    if (v.includes('gris'))         return 'tile--gray-light';
    return '';
  }

  function truncate(str, n) {
    const s = String(str || '');
    return s.length > n ? s.slice(0, n - 1) + '…' : s;
  }

  function normalizeUrl(url) {
    if (!url) return '';
    const u = String(url).trim();
    if (!u) return '';
    if (/^https?:\/\//i.test(u)) return u;
    return 'https://' + u;
  }
  function decodeMany(s, max) {
    let out = String(s || '');
    for (let i = 0; i < (max || 6); i++) {
      try {
        const d = decodeURIComponent(out);
        if (d === out) break;
        out = d;
      } catch (e) { break; }
    }
    return out;
  }

  function makeWrapperUrl(url) {
    const raw = String(url || '').trim();
    if (!raw) return '';

    // ✅ Liens historiques mal formés (ex: /guide/0306/#avisp) : on les normalise vers le routeur racine
    if (raw.includes('/guide/0306/#')) return raw.replace('/guide/0306/#', '/guide/#');

    // Routes deja propres
    if (raw.startsWith(PORTAL_ROOT + '#')) return raw;

    // 1) Normalisation
    let u = normalizeUrl(raw);
    if (!u) return '';

    // 2) Si deja wrapper (ancien #... ou nouveau ?src=...), on extrait la cible pour pouvoir router
    if (u.includes(WRAPPER_MARKER)) {
      try {
        const uu = new URL(u);
        const src = uu.searchParams.get('src');
        if (src) {
          const decoded = decodeMany(src, 10);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        } else if (uu.hash && uu.hash.length > 1) {
          const decoded = decodeMany(uu.hash.slice(1), 8);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        }
      } catch (e) {
        const idx = u.indexOf('#');
        if (idx > -1 && idx < u.length - 1) {
          const decoded = decodeMany(u.slice(idx + 1), 8);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        }
      }
    }

    // 3) Externe (non Grist) : on laisse tel quel
    if (!u.includes('docs.getgrist.com')) return u;

    // 4) Pages "cles" : routes internes
    for (const r of GRIST_KEY_ROUTES) {
      if (u.includes(r.match)) return r.to;
    }

    // 5) Sinon : wrapper ?src= (deep-link/QR)
    return WRAPPER_BASE + encodeURIComponent(u);
  }
  function navigateTop(url) {
    if (!url) return;

    // Important : dans Grist (iframe sandbox), modifier top.location.hash peut être bloqué.
    // La stratégie la plus fiable est de naviguer l'onglet "top" vers l'URL complète (avec #...).
    try {
      if (window.top && window.top !== window) {
        window.top.location.href = url;
        return;
      }
    } catch (e) {
      // ignore et on tente autre chose
    }

    // Fallback : certains contextes sandbox autorisent window.open(..., '_top') même si top est bloqué.
    try {
      window.open(url, '_top');
      return;
    } catch (e) {
      // ignore
    }

    // Dernier recours
    window.location.href = url;
  }

  // Tri Historique : Date_heure décroissante, sinon id décroissant
  function sortHistoriqueRows(rows) {
    return rows.slice().sort((a, b) => {
      const da = a.Date_heure ? new Date(a.Date_heure).getTime() : NaN;
      const db = b.Date_heure ? new Date(b.Date_heure).getTime() : NaN;

      if (!isNaN(da) && !isNaN(db)) {
        return db - da; // plus récents d'abord
      }
      const ia = typeof a.id === 'number' ? a.id : 0;
      const ib = typeof b.id === 'number' ? b.id : 0;
      return ib - ia;
    });
  }

  function buildTiles(blocsRowsAll, filInfoRows, histRows, layoutRow) {
    const grid = document.getElementById('tileGrid');
    grid.innerHTML = '';

    const layoutCols = layoutRow && layoutRow.Nbre_colonne
      ? Number(layoutRow.Nbre_colonne) || 4
      : 4;

    const maxBlocks = layoutRow && layoutRow.Nbre_Bloc
      ? Number(layoutRow.Nbre_Bloc) || blocsRowsAll.length
      : blocsRowsAll.length;

    if (!blocsRowsAll.length) {
      const msg = document.createElement('div');
      msg.style.gridColumn = '1 / -1';
      msg.style.padding = '12px 16px';
      msg.style.borderRadius = '12px';
      msg.style.background = 'rgba(220, 38, 38, 0.12)';
      msg.style.border = '1px solid rgba(248, 113, 113, 0.4)';
      msg.style.fontSize = '0.8rem';
      msg.textContent =
        `Aucun bloc trouvé pour la page "${PAGE_NAME}". ` +
        `Vérifie la colonne "Page" dans la table "Blocs".`;
      grid.appendChild(msg);
      return;
    }

    const blocsRows = blocsRowsAll
      .slice()
      .sort((a, b) => (a.num_bloc || 0) - (b.num_bloc || 0))
      .slice(0, maxBlocks);

    const nbBlocs = blocsRows.length;
    const cssCols = Math.min(layoutCols, nbBlocs || layoutCols);
    document.documentElement.style.setProperty('--grid-columns', cssCols);

    const cols = layoutCols;

    const counts = {};
    blocsRows.forEach(b => {
      const t = b.Titre_bloc || '';
      counts[t] = (counts[t] || 0) + 1;
    });
    const duplicates = new Set(Object.keys(counts).filter(t => counts[t] > 1));
    const already = new Set();

    const newsNorm = normalizeName('Fil info');
    const byTitle = {};
    blocsRows.forEach(b => {
      const t = b.Titre_bloc || '';
      if (!byTitle[t]) byTitle[t] = [];
      byTitle[t].push(b);
    });

    blocsRows.forEach(bloc => {
      const title = bloc.Titre_bloc || '';
      const dup = duplicates.has(title);
      if (dup) {
        if (already.has(title)) return;
        already.add(title);
      }

      const tile = document.createElement('div');
      tile.className = 'tile';

      const colorClass = colorToClass(bloc.Couleur);
      if (colorClass) tile.classList.add(colorClass);

      if (dup && byTitle[title].length === 2) {
        const [b1, b2] = byTitle[title].sort((x, y) => x.num_bloc - y.num_bloc);
        const pos1 = (b1.num_bloc || 1) - 1;
        const pos2 = (b2.num_bloc || 1) - 1;
        const r1 = Math.floor(pos1 / cols), c1 = pos1 % cols;
        const r2 = Math.floor(pos2 / cols), c2 = pos2 % cols;

        if (normalizeName(title) === newsNorm) {
          tile.classList.add('tile--tall');
        } else if (r1 === r2 && Math.abs(c1 - c2) === 1) {
          tile.classList.add('tile--wide');
        } else if (c1 === c2 && Math.abs(r1 - r2) === 1) {
          tile.classList.add('tile--tall');
        }
      }

      const icon = document.createElement('div');
      icon.className = 'tile-icon';
      icon.textContent = bloc.Initiale_bloc || '';
      tile.appendChild(icon);

      const main = document.createElement('div');
      main.className = 'tile-main';
      tile.appendChild(main);

      const titleEl = document.createElement('div');
      titleEl.className = 'tile-title';
      titleEl.textContent = title || '(sans titre)';
      main.appendChild(titleEl);

      const descEl = document.createElement('div');
      descEl.className = 'tile-desc';
      descEl.textContent = bloc.Sous_titre1 || '';
      main.appendChild(descEl);

      const isNews = normalizeName(title) === newsNorm;

      if (isNews) {
        const hasAny = (filInfoRows && filInfoRows.length) || (histRows && histRows.length);

        if (!hasAny) {
          // Rien à afficher : petit message neutre
          const msg = document.createElement('div');
          msg.style.fontSize = '0.8rem';
          msg.style.opacity = '0.7';
          msg.textContent = 'Aucune information à afficher pour le moment.';
          main.appendChild(msg);
        } else {
          tile.style.cursor = 'default';

          const viewport = document.createElement('div');
          viewport.className = 'news-viewport';
          const track = document.createElement('div');
          track.className = 'news-track';
          viewport.appendChild(track);

          // --- Fil info (inchangé : avec lien) ---
          const makeItemFilInfo = row => {
            const a = document.createElement('a');
            a.className = 'news-item';

            const t  = row.Titre || '';
            const st = row.Sous_titre || '';
            const c  = truncate(row.Contenu || '', 20);
            a.textContent = `${t} — ${st} : ${c}`;

            const url = makeWrapperUrl(row.Lien);
            if (url) {
              a.href   = url;
              a.target = '_top';
            } else {
              a.href = '#';
            }
            return a;
          };

          const filItems = (filInfoRows || []).map(makeItemFilInfo);

          // --- Historique_equipements : 10 dernières lignes, texte seul (Details), pas de lien ---
          const histItems = (histRows || []).map(row => {
            const div = document.createElement('div');
            div.className = 'news-item';
            const txt = row.Details || row.DETAILS || '';
            div.textContent = truncate(txt, 80);
            return div;
          });

          // On prépare une base d’items (Fil info + Historique)
          const baseItems = [...filItems, ...histItems];

          // Sécurité : si, pour une raison X, on n’a rien, on met un placeholder
          const effectiveBase = baseItems.length ? baseItems : ([
            (() => {
              const d = document.createElement('div');
              d.className = 'news-item';
              d.textContent = 'Aucune information à afficher pour le moment.';
              return d;
            })()
          ]);

          // On force un nombre FIXE d’éléments dans la piste pour découpler du nombre de lignes
          const TARGET_COUNT = 20; // par ex. 20 items dans le track
          for (let i = 0; i < TARGET_COUNT; i++) {
            const src = effectiveBase[i % effectiveBase.length];
            track.appendChild(src.cloneNode(true));
          }

          main.appendChild(viewport);
        }

      } else {
        const sousG = bloc.Sous_titre_G;
        const sousD = bloc.Sous_titre_D;

        if (sousG || sousD) {
          const bottom = document.createElement('div');
          bottom.className = 'tile-bottom-links';

          if (sousG) {
            const aG = document.createElement('a');
            aG.className = 'tile-link';
            aG.textContent = sousG;
            if (bloc.Url_G) {
              const urlG = makeWrapperUrl(bloc.Url_G);
              if (urlG) {
                aG.href   = urlG;
                aG.target = '_top';
              } else {
                aG.href = '#';
              }
            } else {
              aG.href = '#';
            }
            bottom.appendChild(aG);
          }

          if (sousD) {
            const aD = document.createElement('a');
            aD.className = 'tile-link';
            aD.textContent = sousD;
            if (bloc.Url_D) {
              const urlD = makeWrapperUrl(bloc.Url_D);
              if (urlD) {
                aD.href   = urlD;
                aD.target = '_top';
              } else {
                aD.href = '#';
              }
            } else {
              aD.href = '#';
            }
            bottom.appendChild(aD);
          }

          main.appendChild(bottom);

        } else if (bloc.Url_bloc) {
          const urlBloc = makeWrapperUrl(bloc.Url_bloc);

          tile.addEventListener('click', () => {
            if (!urlBloc) return;
            navigateTop(urlBloc);
          });
          tile.tabIndex = 0;
          tile.setAttribute('role', 'link');
          tile.addEventListener('keypress', e => {
            if ((e.key === 'Enter' || e.key === ' ') && urlBloc) {
              e.preventDefault();
              navigateTop(urlBloc);
            }
          });
        }
      }

      grid.appendChild(tile);
    });
  }

  async function loadFromGrist() {
    const doc = (window.PP_IS_GRIST ? grist.docApi : null);

    // On récupère ce qui sert aux tuiles + l'historique
    const [tAgenc, tBlocs, tFil] = await Promise.all([
      PP_fetchTable('Agencement_portail'),
      PP_fetchTable('Blocs'),
      PP_fetchTable('Fil_info')
    ]);

    let tHist = null;
    try {
      tHist = await PP_fetchTable('Historique_equipements');
    } catch (e) {
      console.warn('Historique_equipements non accessible', e);
    }

    const agRows    = rowsToRecordsCompat(tAgenc);
    const blocsAll  = rowsToRecordsCompat(tBlocs);
    const filInfo   = rowsToRecordsCompat(tFil);
    const histAll   = tHist ? rowsToRecordsCompat(tHist) : [];
    const histSorted = sortHistoriqueRows(histAll);
    const histLast10 = histSorted.slice(0, 10); // toujours les 10 derniers au moment du chargement

    const currentNorm = normalizeName(PAGE_NAME);

    let agencementName = PAGE_NAME;
    if (currentNorm === normalizeName('Portail')) {
      agencementName = 'Accueil';
    } else if (currentNorm === normalizeName('Acces_Admin')) {
      agencementName = 'Accès Admin';
    } else if (currentNorm === normalizeName('Acces_DDFPT')) {
      agencementName = 'Accès DDFPT';
    }

    const layoutRow =
      agRows.find(r => normalizeName(r.Page) === normalizeName(agencementName)) ||
      agRows[0] || null;

    const blocsRowsAll = blocsAll.filter(
      b => normalizeName(b.Page) === normalizeName(PAGE_NAME)
    );

    buildTiles(blocsRowsAll, filInfo, histLast10, layoutRow);
  }

document.addEventListener('DOMContentLoaded', () => {
  const inGrist = !!window.PP_IS_GRIST;

  if (inGrist) {
    // On est vraiment dans un widget Grist (iframe)
    grist.ready();
  } else {
    // On est sur GitHub Pages : surtout PAS de grist.ready()
    console.log("Mode GitHub : chargement via Supabase (PP_fetchTable)");
  }

  // IMPORTANT : on charge les tuiles dans tous les cas
  // car PP_fetchTable choisit Grist ou Supabase selon PP_IS_GRIST
  loadFromGrist().catch(err => console.error('Erreur chargement tuiles', err));
});

</script>
<script src="../js/pp-config.js"></script>
<script src="../js/pp-header.js"></script>

</body>
</html>
