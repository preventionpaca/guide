<!DOCTYPE html>
<html lang="fr">
<head>
  <script>
    window.PP_APP_NAME = "site";
  </script>
  <meta charset="UTF-8" />
  <title>Portail prévention PACA – Accès DDFPT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- API Grist -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

  <script>
    // ===============================
    // PPP Data Layer (GitHub + Grist)
    // - Lecture: PP_fetchTable(table)
    // - En dehors de Grist: utilise Supabase Edge Function read-app
    // ===============================
    (function () {
      const DEFAULT_SB = "https://hpiqwvwpxzppxpxhjede.supabase.co";
      const sbBase = (window.PP_SUPABASE_URL || DEFAULT_SB).replace(/\/+$/, "");
      const SB_ROOT = sbBase + "/functions/v1";

      // IMPORTANT: dans votre cas, le docId est résolu via resolve-app => app= "equipements"
      window.PP_APP_NAME = window.PP_APP_NAME || "equipements";

      window.PP_SB_ROOT = SB_ROOT;
      window.PP_SB_API_READ = SB_ROOT + "/read-app";
      window.PP_SB_API_AUTH = SB_ROOT + "/auth-code";
      window.PP_SB_API_WRITE = SB_ROOT + "/write-app";

      window.PP_IS_GRIST = !!(
        window.grist &&
        window.grist.docApi &&
        typeof window.grist.docApi.fetchTable === "function" &&
        window.parent !== window
      );

      function rowsToGristTable(rows) {
        if (!Array.isArray(rows) || !rows.length) return { id: [] };
        const cols = new Set();
        for (const r of rows) Object.keys(r || {}).forEach((k) => cols.add(k));
        cols.delete("id");
        const t = { id: [] };
        for (const c of cols) t[c] = [];
        for (const r of rows) {
          t.id.push(r.id);
          for (const c of cols) t[c].push(r[c]);
        }
        return t;
      }

      async function sbFetchTable(tableName) {
        const url = window.PP_SB_API_READ +
          "?app=" + encodeURIComponent(window.PP_APP_NAME) +
          "&table=" + encodeURIComponent(tableName);

        const r = await fetch(url, { credentials: "omit" });
        const j = await r.json().catch(() => null);

        if (!r.ok || !j || !j.ok) {
          throw new Error(j?.error || "Lecture Supabase impossible");
        }

        // ✅ Support formats possibles:
        // 1) { table: {id:[], ...} }
        if (j.table) return j.table;

        // 2) { rows: [...] } ou { data:[...] } ou { items:[...] }
        if (Array.isArray(j.rows)) return rowsToGristTable(j.rows);
        if (Array.isArray(j.data)) return rowsToGristTable(j.data);
        if (Array.isArray(j.items)) return rowsToGristTable(j.items);

        // 3) { records: [{id, fields:{...}}] } (format Grist-like)
        if (Array.isArray(j.records)) {
          const rows = j.records.map((rec) => ({ id: rec.id, ...(rec.fields || {}) }));
          return rowsToGristTable(rows);
        }

        // 4) { tables: {TableName: {id:[], ...}} }
        if (j.tables && j.tables[tableName]) return j.tables[tableName];

        return j;
      }

      window.PP_fetchTable = async function (tableName) {
        if (window.PP_IS_GRIST) return window.grist.docApi.fetchTable(tableName);
        return sbFetchTable(tableName);
      };

      // ✅ Shim: pour éviter de retoucher 50 scripts existants
      if (!window.PP_IS_GRIST) {
        window.grist = window.grist || {};
        window.grist.docApi = window.grist.docApi || {};
        window.grist.docApi.fetchTable = window.PP_fetchTable;

        if (typeof window.grist.rowsToRecords !== "function") {
          window.grist.rowsToRecords = function (table) {
            const ids = table.id || [];
            const records = [];
            let cols = {};

            if (table.fields && typeof table.fields === "object") cols = table.fields;
            else {
              for (const [k, v] of Object.entries(table)) {
                if (k === "id") continue;
                if (Array.isArray(v)) cols[k] = v;
              }
            }

            for (let i = 0; i < ids.length; i++) {
              const rec = { id: ids[i] };
              for (const [k, arr] of Object.entries(cols)) rec[k] = arr[i];
              records.push(rec);
            }
            return records;
          };
        }
      }
    })();
  </script>

  <!-- CSS commun + portail -->
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-core.css" />
  <link rel="stylesheet" href="https://preventionpaca.github.io/guide/css/pp-portail.css" />

  <!-- ===== CSS LIGHTBOX ACCÈS DDFPT (ancienne lightbox conservée, mais neutralisée) ===== -->
  <style>
    .pp-lock-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pp-lock-modal {
      background: #0b2238;
      color: #e5f0ff;
      border-radius: 18px;
      padding: 24px 28px;
      max-width: 380px;
      width: 90%;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.6);
      border: 1px solid #f97316;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    .pp-lock-title {
      margin: 0 0 4px;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .pp-lock-sub {
      margin: 0 0 16px;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .pp-lock-input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid #374151;
      padding: 8px 12px;
      margin-bottom: 8px;
      background: #020617;
      color: #e5f0ff;
      font-size: 0.9rem;
    }
    .pp-lock-input:focus {
      outline: none;
      border-color: #f97316;
      box-shadow: 0 0 0 1px rgba(249, 115, 22, 0.7);
    }
    .pp-lock-actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
    }
    .pp-lock-btn {
      border-radius: 999px;
      border: none;
      padding: 7px 16px;
      font-size: 0.85rem;
      cursor: pointer;
      background: transparent;
      color: #e5f0ff;
    }
    .pp-lock-btn-primary {
      background: #f97316;
      color: #111827;
      font-weight: 600;
    }
    .pp-lock-btn-primary:hover {
      filter: brightness(1.06);
    }
    .pp-lock-error {
      margin: 4px 0 0;
      font-size: 0.8rem;
      color: #fecaca;
      min-height: 1.1em;
    }
    .pp-lock-attempts {
      margin-top: 2px;
      font-size: 0.75rem;
      color: #9ca3af;
    }
  </style>
</head>

<body>
<div class="page-wrap">

  <div id="header-container"></div>

  <section class="tile-frame">
    <main id="tileGrid" class="tile-grid"></main>
  </section>

</div>



<!-- ===== SCRIPT TUILES (chargement reporté après auth) ===== -->
<script>
  const PAGE_NAME = 'Acces_DDFPT';

  const PORTAL_ROOT = 'https://preventionpaca.github.io/guide/';
  const ROUTES = {
    home: PORTAL_ROOT + '#home',
    base: PORTAL_ROOT + '#base',
    medicalStd: PORTAL_ROOT + '#medical',
    medicalCustom: PORTAL_ROOT + '#medical-custom'
  };

  const HOME_URL = PORTAL_ROOT + '#home';
  function goHome(evt) {
    if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();
    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'pp:navigate', key: 'home' }, '*');
      }
    } catch (e) {}
    try {
      if (window.top && window.top !== window) {
        window.top.location.href = HOME_URL;
        return;
      }
    } catch (e) {}
    try {
      window.location.hash = '#home';
      setTimeout(() => { window.location.href = HOME_URL; }, 50);
    } catch (e) {
      try { window.location.href = HOME_URL; } catch (e2) {}
    }
  }

  const WRAPPER_BASE   = 'https://preventionpaca.github.io/guide/guide_iframe.html?src=';
  const WRAPPER_MARKER = 'guide_iframe.html';

  const GRIST_KEY_ROUTES = [
    { match: '/p/59',  to: ROUTES.home },
    { match: '/p/119', to: ROUTES.base },
    { match: '/p/67',  to: ROUTES.medicalStd },
    { match: '/p/141', to: ROUTES.medicalCustom }
  ];

  function rowsToRecordsCompat(table) {
    if (window.grist && typeof grist.rowsToRecords === 'function') {
      return grist.rowsToRecords(table);
    }
    const ids = table.id || [];
    const records = [];
    let columnArrays = {};

    if (table.fields && typeof table.fields === 'object') {
      columnArrays = table.fields;
    } else {
      for (const [key, value] of Object.entries(table)) {
        if (key === 'id') continue;
        if (Array.isArray(value)) columnArrays[key] = value;
      }
    }

    for (let i = 0; i < ids.length; i++) {
      const rec = { id: ids[i] };
      for (const [col, values] of Object.entries(columnArrays)) {
        rec[col] = values[i];
      }
      records.push(rec);
    }
    return records;
  }

  function normalizeName(v) {
    if (!v) return '';
    let s = String(v).trim().toLowerCase();
    try { s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch (e) {}
    s = s.replace(/[_\s]+/g, ' ').replace(/\s+/g, ' ');
    return s;
  }

  function colorToClass(c) {
    if (!c) return '';
    const v = String(c).toLowerCase();
    if (v.includes('blanc'))        return 'tile--white';
    if (v.includes('vert'))         return 'tile--green';
    if (v.includes('orange'))       return 'tile--orange';
    if (v.includes('noir'))         return 'tile--dark';
    if (v.includes('marron clair')) return 'tile--brown-light';
    if (v.includes('marron fon'))   return 'tile--brown-dark';
    if (v.includes('gris'))         return 'tile--gray-light';
    return '';
  }

  function truncate(str, n) {
    const s = String(str || '');
    return s.length > n ? s.slice(0, n - 1) + '…' : s;
  }

  function normalizeUrl(url) {
    if (!url) return '';
    const u = String(url).trim();
    if (!u) return '';
    if (/^https?:\/\//i.test(u)) return u;
    return 'https://' + u;
  }

  function decodeMany(s, max) {
    let out = String(s || '');
    for (let i = 0; i < (max || 6); i++) {
      try {
        const d = decodeURIComponent(out);
        if (d === out) break;
        out = d;
      } catch (e) { break; }
    }
    return out;
  }

  function makeWrapperUrl(url) {
    const raw = String(url || '').trim();
    if (!raw) return '';
    if (raw.startsWith(PORTAL_ROOT + '#')) return raw;

    let u = normalizeUrl(raw);
    if (!u) return '';

    if (u.includes(WRAPPER_MARKER)) {
      try {
        const uu = new URL(u);
        const src = uu.searchParams.get('src');
        if (src) {
          const decoded = decodeMany(src, 10);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        } else if (uu.hash && uu.hash.length > 1) {
          const decoded = decodeMany(uu.hash.slice(1), 8);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        }
      } catch (e) {
        const idx = u.indexOf('#');
        if (idx > -1 && idx < u.length - 1) {
          const decoded = decodeMany(u.slice(idx + 1), 8);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        }
      }
    }

    if (!u.includes('docs.getgrist.com')) return u;

    for (const r of GRIST_KEY_ROUTES) {
      if (u.includes(r.match)) return r.to;
    }

    return WRAPPER_BASE + encodeURIComponent(u);
  }

  function navigateTop(url) {
    if (!url) return;

    const isPortalRoute = String(url).startsWith(PORTAL_ROOT + '#');

    try {
      const topWin = (window.top && window.top !== window) ? window.top : window;

      if (isPortalRoute) {
        const current = String(topWin.location.href || '');
        if (current.includes('/guide/') && current.includes('preventionpaca.github.io')) {
          topWin.location.hash = String(url).split('#')[1] || '';
          return;
        }
      }

      topWin.location.href = url;
    } catch (e) {
      window.location.href = url;
    }
  }

  function buildTiles(blocsRowsAll, filInfoRows, layoutRow) {
    const grid = document.getElementById('tileGrid');
    grid.innerHTML = '';

    const layoutCols = layoutRow && layoutRow.Nbre_colonne
      ? Number(layoutRow.Nbre_colonne) || 4
      : 4;

    const maxBlocks = layoutRow && layoutRow.Nbre_Bloc
      ? Number(layoutRow.Nbre_Bloc) || blocsRowsAll.length
      : blocsRowsAll.length;

    if (!blocsRowsAll.length) {
      const msg = document.createElement('div');
      msg.style.gridColumn = '1 / -1';
      msg.style.padding = '12px 16px';
      msg.style.borderRadius = '12px';
      msg.style.background = 'rgba(220, 38, 38, 0.12)';
      msg.style.border = '1px solid rgba(248, 113, 113, 0.4)';
      msg.style.fontSize = '0.8rem';
      msg.textContent =
        `Aucun bloc trouvé pour la page "${PAGE_NAME}". ` +
        `Vérifie la colonne "Page" dans la table "Blocs".`;
      grid.appendChild(msg);
      return;
    }

    const blocsRows = blocsRowsAll
      .slice()
      .sort((a, b) => (a.num_bloc || 0) - (b.num_bloc || 0))
      .slice(0, maxBlocks);

    const nbBlocs = blocsRows.length;
    const cssCols = Math.min(layoutCols, nbBlocs || layoutCols);
    document.documentElement.style.setProperty('--grid-columns', cssCols);

    const cols = layoutCols;

    const counts = {};
    blocsRows.forEach(b => {
      const t = b.Titre_bloc || '';
      counts[t] = (counts[t] || 0) + 1;
    });
    const duplicates = new Set(Object.keys(counts).filter(t => counts[t] > 1));
    const already = new Set();

    const newsNorm = normalizeName('Fil info');
    const byTitle = {};
    blocsRows.forEach(b => {
      const t = b.Titre_bloc || '';
      if (!byTitle[t]) byTitle[t] = [];
      byTitle[t].push(b);
    });

    blocsRows.forEach(bloc => {
      const title = bloc.Titre_bloc || '';
      const dup = duplicates.has(title);
      if (dup) {
        if (already.has(title)) return;
        already.add(title);
      }

      const tile = document.createElement('div');
      tile.className = 'tile';

      const colorClass = colorToClass(bloc.Couleur);
      if (colorClass) tile.classList.add(colorClass);

      if (dup && byTitle[title].length === 2) {
        const [b1, b2] = byTitle[title].sort((x, y) => x.num_bloc - y.num_bloc);
        const pos1 = (b1.num_bloc || 1) - 1;
        const pos2 = (b2.num_bloc || 1) - 1;
        const r1 = Math.floor(pos1 / cols), c1 = pos1 % cols;
        const r2 = Math.floor(pos2 / cols), c2 = pos2 % cols;

        if (normalizeName(title) === newsNorm) {
          tile.classList.add('tile--tall');
        } else if (r1 === r2 && Math.abs(c1 - c2) === 1) {
          tile.classList.add('tile--wide');
        } else if (c1 === c2 && Math.abs(r1 - r2) === 1) {
          tile.classList.add('tile--tall');
        }
      }

      const icon = document.createElement('div');
      icon.className = 'tile-icon';
      icon.textContent = bloc.Initiale_bloc || '';
      tile.appendChild(icon);

      const main = document.createElement('div');
      main.className = 'tile-main';
      tile.appendChild(main);

      const titleEl = document.createElement('div');
      titleEl.className = 'tile-title';
      titleEl.textContent = title || '(sans titre)';
      main.appendChild(titleEl);

      const descEl = document.createElement('div');
      descEl.className = 'tile-desc';
      descEl.textContent = bloc.Sous_titre1 || '';
      main.appendChild(descEl);

      const isNews = normalizeName(title) === newsNorm;

      if (isNews && filInfoRows.length) {
        tile.style.cursor = 'default';

        const viewport = document.createElement('div');
        viewport.className = 'news-viewport';
        const track = document.createElement('div');
        track.className = 'news-track';
        viewport.appendChild(track);

        const makeItem = row => {
          const a = document.createElement('a');
          a.className = 'news-item';

          const t = row.Titre || '';
          const st = row.Sous_titre || '';
          const c = truncate(row.Contenu || '', 20);
          a.textContent = `${t} — ${st} : ${c}`;

          const url = makeWrapperUrl(row.Lien);
          if (url) {
            a.href   = url;
            a.target = '_top';
          } else {
            a.href = '#';
          }
          return a;
        };

        const items = filInfoRows.map(makeItem);
        [...items, ...items].forEach(it => track.appendChild(it));
        main.appendChild(viewport);

      } else {
        const sousG = bloc.Sous_titre_G;
        const sousD = bloc.Sous_titre_D;

        if (sousG || sousD) {
          const bottom = document.createElement('div');
          bottom.className = 'tile-bottom-links';

          if (sousG) {
            const aG = document.createElement('a');
            aG.className = 'tile-link';
            aG.textContent = sousG;
            if (bloc.Url_G) {
              const urlG = makeWrapperUrl(bloc.Url_G);
              aG.href   = urlG || '#';
              aG.target = '_top';
            } else {
              aG.href = '#';
            }
            bottom.appendChild(aG);
          }

          if (sousD) {
            const aD = document.createElement('a');
            aD.className = 'tile-link';
            aD.textContent = sousD;
            if (bloc.Url_D) {
              const urlD = makeWrapperUrl(bloc.Url_D);
              aD.href   = urlD || '#';
              aD.target = '_top';
            } else {
              aD.href = '#';
            }
            bottom.appendChild(aD);
          }

          main.appendChild(bottom);

        } else if (bloc.Url_bloc) {
          const urlBloc = makeWrapperUrl(bloc.Url_bloc);

          tile.addEventListener('click', () => {
            if (!urlBloc) return;
            navigateTop(urlBloc);
          });
          tile.tabIndex = 0;
          tile.setAttribute('role', 'link');
          tile.addEventListener('keypress', e => {
            if ((e.key === 'Enter' || e.key === ' ') && urlBloc) {
              e.preventDefault();
              navigateTop(urlBloc);
            }
          });
        }
      }

      grid.appendChild(tile);
    });
  }

  async function loadFromGrist() {
    const doc = grist.docApi;

    const [tAgenc, tBlocs, tFil] = await Promise.all([
      doc.fetchTable('Agencement_portail'),
      doc.fetchTable('Blocs'),
      doc.fetchTable('Fil_info'),
    ]);

    const agRows   = rowsToRecordsCompat(tAgenc);
    const blocsAll = rowsToRecordsCompat(tBlocs);
    const filInfo  = rowsToRecordsCompat(tFil);

    const currentNorm = normalizeName(PAGE_NAME);
    let agencementName = PAGE_NAME;
    if (currentNorm === normalizeName('Portail')) {
      agencementName = 'Accueil';
    } else if (currentNorm === normalizeName('Acces_Admin')) {
      agencementName = 'Accès Admin';
    } else if (currentNorm === normalizeName('Acces_DDFPT')) {
      agencementName = 'Accès DDFPT';
    }

    const layoutRow =
      agRows.find(r => normalizeName(r.Page) === normalizeName(agencementName)) ||
      agRows[0] || null;

    const blocsRowsAll = blocsAll.filter(
      b => normalizeName(b.Page) === normalizeName(PAGE_NAME)
    );

    buildTiles(blocsRowsAll, filInfo, layoutRow);
  }

  // ✅ Point d’entrée unique : appelé APRÈS auth (PP_AUTH)
  window.startPage = async function startPage() {
    try {
      if (window.PP_IS_GRIST && window.grist && window.grist.ready) {
        grist.ready();
      }
    } catch (e) {}
    await loadFromGrist();
  };
</script>

<!-- Header commun + config (charger config avant header) -->
<script>
  window.PP_PAGE = "ddfpt";
</script>
<script src="https://preventionpaca.github.io/guide/js/pp-config.js"></script>

<!-- ✅ Verrou global : identification au démarrage, puis lancement startPage() -->
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      await window.PP_AUTH.requireDdfpt();

      // Neutralise l’ancienne lightbox locale
      const oldOverlay = document.getElementById('ppLockOverlay');
      if (oldOverlay) oldOverlay.style.display = 'none';

      if (typeof window.startPage === 'function') {
        await window.startPage();
      } else {
        console.error('startPage() introuvable');
      }
    } catch (e) {
      // AUTH_REQUIRED => PP_AUTH ouvre sa modal, on ne lance rien.
    }
  });
</script>

<script src="https://preventionpaca.github.io/guide/js/pp-header.js"></script>

</body>
</html>
