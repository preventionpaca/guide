<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Portail prévention PACA – Accès DDFPT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- API Grist -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

<script>
/* ==========================================================
   PP_DATA_LAYER (GitHub Pages + Grist)
   - Si la page est dans Grist: utilise grist.docApi.fetchTable/applyUserActions
   - Sinon: utilise Supabase Edge Functions (read-app/auth-code/write-app)
   ========================================================== */
(function(){
  const DEFAULT_SB = "https://hpiqwvwpxzppxpxhjede.supabase.co";
  const sbBase = (window.PP_SUPABASE_URL || DEFAULT_SB).replace(/\/+$/,'');
  const SB_ROOT = sbBase + "/functions/v1";
  window.PP_SB_ROOT = SB_ROOT;
  window.PP_SB_API_READ  = SB_ROOT + "/read-app";
  window.PP_SB_API_AUTH  = SB_ROOT + "/auth-code";
  window.PP_SB_API_WRITE = SB_ROOT + "/write-app";
  window.PP_APP_NAME = window.PP_APP_NAME || "ddfpt";
  window.PP_IS_GRIST = !!(window.grist && window.grist.docApi && typeof window.grist.docApi.fetchTable === 'function');

  function rowsToGristTable(rows){
    if(!Array.isArray(rows) || !rows.length) return {id:[]};
    const cols = new Set();
    for(const r of rows) Object.keys(r||{}).forEach(k=>cols.add(k));
    cols.delete('id');
    const t={id:[]};
    for(const c of cols) t[c]=[];
    for(const r of rows){
      t.id.push(r.id);
      for(const c of cols) t[c].push(r[c]);
    }
    return t;
  }

  async function sbFetchTable(tableName){
    const url1 = window.PP_SB_API_READ + "?app=" + encodeURIComponent(window.PP_APP_NAME) + "&table=" + encodeURIComponent(tableName);
    let r = await fetch(url1, {credentials:'omit'});
    let j = await r.json().catch(()=>null);
    if(j && j.ok){
      if(j.table) return j.table;
      if(Array.isArray(j.rows)) return rowsToGristTable(j.rows);
      if(Array.isArray(j.data)) return rowsToGristTable(j.data);
      if(j.items && Array.isArray(j.items)) return rowsToGristTable(j.items);
      if(j.tables && j.tables[tableName]) return j.tables[tableName];
      return j;
    }
    const url2 = window.PP_SB_API_READ + "?app=" + encodeURIComponent(window.PP_APP_NAME);
    r = await fetch(url2, {credentials:'omit'});
    j = await r.json().catch(()=>null);
    if(j && j.ok && j.tables && j.tables[tableName]) return j.tables[tableName];
    throw new Error(j?.error || "Lecture Supabase impossible");
  }

  window.PP_fetchTable = async function(tableName){
    if(window.PP_IS_GRIST) return window.grist.docApi.fetchTable(tableName);
    return sbFetchTable(tableName);
  };
})();
</script>


  <!-- CSS commun + portail -->
  <link rel="stylesheet" href="../css/pp-core.css" />
  <link rel="stylesheet" href="../css/pp-portail.css" />

  <!-- ===== CSS LIGHTBOX ACCÈS DDFPT ===== -->
  <style>
    .pp-lock-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pp-lock-modal {
      background: #0b2238;
      color: #e5f0ff;
      border-radius: 18px;
      padding: 24px 28px;
      max-width: 380px;
      width: 90%;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.6);
      border: 1px solid #f97316;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    .pp-lock-title {
      margin: 0 0 4px;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .pp-lock-sub {
      margin: 0 0 16px;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .pp-lock-input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid #374151;
      padding: 8px 12px;
      margin-bottom: 8px;
      background: #020617;
      color: #e5f0ff;
      font-size: 0.9rem;
    }
    .pp-lock-input:focus {
      outline: none;
      border-color: #f97316;
      box-shadow: 0 0 0 1px rgba(249, 115, 22, 0.7);
    }
    .pp-lock-actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
    }
    .pp-lock-btn {
      border-radius: 999px;
      border: none;
      padding: 7px 16px;
      font-size: 0.85rem;
      cursor: pointer;
      background: transparent;
      color: #e5f0ff;
    }
    .pp-lock-btn-primary {
      background: #f97316;
      color: #111827;
      font-weight: 600;
    }
    .pp-lock-btn-primary:hover {
      filter: brightness(1.06);
    }
    .pp-lock-error {
      margin: 4px 0 0;
      font-size: 0.8rem;
      color: #fecaca;
      min-height: 1.1em;
    }
    .pp-lock-attempts {
      margin-top: 2px;
      font-size: 0.75rem;
      color: #9ca3af;
    }
  </style>
</head>

<body>
<div class="page-wrap">

  <div id="header-container"></div>

  <section class="tile-frame">
    <main id="tileGrid" class="tile-grid"></main>
  </section>

</div>

<!-- ===== LIGHTBOX ACCÈS DDFPT ===== -->
<div id="ppLockOverlay" class="pp-lock-overlay" aria-modal="true" role="dialog">
  <div class="pp-lock-modal">
    <h2 class="pp-lock-title">Accès réservé</h2>
    <p class="pp-lock-sub">
      Cette page est réservée aux Directeurs Délégués aux Formations.
      Merci de saisir le code d’accès.
    </p>
    <input
      id="ppLockInput"
      class="pp-lock-input"
      type="password"
      autocomplete="off"
      placeholder="Code DDFPT"
    />
    <div id="ppLockError" class="pp-lock-error"></div>
    <div id="ppLockAttempts" class="pp-lock-attempts"></div>
    <div class="pp-lock-actions">
      <button id="ppLockCancel" class="pp-lock-btn" type="button">Annuler</button>
      <button id="ppLockSubmit" class="pp-lock-btn pp-lock-btn-primary" type="button">
        Valider
      </button>
    </div>
  </div>
</div>

<!-- ===== SCRIPT TUILES + VERROU ACCÈS DDFPT ===== -->
<script>
  // ⚠️ Nom de page côté Grist (table Pages / Blocs)
  const PAGE_NAME = 'Acces_DDFPT';

  // Racine du portail (index.html)
  const PORTAL_ROOT = 'https://preventionpaca.github.io/guide/';
  const ROUTES = {
    home: PORTAL_ROOT + '#home',
    base: PORTAL_ROOT + '#base',
    medicalStd: PORTAL_ROOT + '#medical',
    medicalCustom: PORTAL_ROOT + '#medical-custom'
  };

  // Retour portail fiable (iframe-safe)
  const HOME_URL = PORTAL_ROOT + '#home';
  function goHome(evt) {
    if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();
    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'pp:navigate', key: 'home' }, '*');
      }
    } catch (e) {}

    // Fallback : tentative de navigation "top" (souvent autorisée sur action utilisateur)
    try {
      if (window.top && window.top !== window) {
        window.top.location.href = HOME_URL;
        return;
      }
    } catch (e) {}

    // Dernier recours : navigation locale
    try {
      window.location.hash = '#home';
      setTimeout(() => { window.location.href = HOME_URL; }, 50);
    } catch (e) {
      try { window.location.href = HOME_URL; } catch (e2) {}
    }
  }

  // wrapper QR / deep-link (on conserve)
  const WRAPPER_BASE   = 'https://preventionpaca.github.io/guide/guide_iframe.html?src=';
  const WRAPPER_MARKER = 'guide_iframe.html';

  // mapping Grist -> route interne (pages cles)
  const GRIST_KEY_ROUTES = [
    { match: '/p/59',  to: ROUTES.home },
    { match: '/p/119', to: ROUTES.base },
    { match: '/p/67',  to: ROUTES.medicalStd },
    { match: '/p/141', to: ROUTES.medicalCustom }
  ];

  // ⚠️ CONFIG TABLE CODES : adapté à tes champs
  const ADMIN_TABLE       = 'Administrateur'; // table des codes
  const ADMIN_FIELD_CODE  = 'Code';           // colonne contenant le code
  const ADMIN_FIELD_PAGE  = 'Page';           // optionnel : code dédié à une page

  const ETAB_TABLE = 'Etablissements_edi';
  const ETAB_FIELD_CODE = 'Codepaca';

  const MAX_ATTEMPTS = 3;

  let adminCodes     = [];
  let attemptCount   = 0;
  let accessGranted  = false;

  function rowsToRecordsCompat(table) {
    if (window.grist && typeof grist.rowsToRecords === 'function') {
      return grist.rowsToRecords(table);
    }
    const ids = table.id || [];
    const records = [];
    let columnArrays = {};

    if (table.fields && typeof table.fields === 'object') {
      columnArrays = table.fields;
    } else {
      for (const [key, value] of Object.entries(table)) {
        if (key === 'id') continue;
        if (Array.isArray(value)) columnArrays[key] = value;
      }
    }

    for (let i = 0; i < ids.length; i++) {
      const rec = { id: ids[i] };
      for (const [col, values] of Object.entries(columnArrays)) {
        rec[col] = values[i];
      }
      records.push(rec);
    }
    return records;
  }

  function normalizeName(v) {
    if (!v) return '';
    let s = String(v).trim().toLowerCase();
    try { s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch (e) {}
    s = s.replace(/[_\s]+/g, ' ').replace(/\s+/g, ' ');
    return s;
  }

  function colorToClass(c) {
    if (!c) return '';
    const v = String(c).toLowerCase();
    if (v.includes('blanc'))        return 'tile--white';
    if (v.includes('vert'))         return 'tile--green';
    if (v.includes('orange'))       return 'tile--orange';
    if (v.includes('noir'))         return 'tile--dark';
    if (v.includes('marron clair')) return 'tile--brown-light';
    if (v.includes('marron fon'))   return 'tile--brown-dark';
    if (v.includes('gris'))         return 'tile--gray-light';
    return '';
  }

  function truncate(str, n) {
    const s = String(str || '');
    return s.length > n ? s.slice(0, n - 1) + '…' : s;
  }

  function normalizeUrl(url) {
    if (!url) return '';
    const u = String(url).trim();
    if (!u) return '';
    if (/^https?:\/\//i.test(u)) return u;
    return 'https://' + u;
  }

  function decodeMany(s, max) {
    let out = String(s || '');
    for (let i = 0; i < (max || 6); i++) {
      try {
        const d = decodeURIComponent(out);
        if (d === out) break;
        out = d;
      } catch (e) { break; }
    }
    return out;
  }

  function makeWrapperUrl(url) {
    const raw = String(url || '').trim();
    if (!raw) return '';

    // Routes deja propres
    if (raw.startsWith(PORTAL_ROOT + '#')) return raw;

    // 1) Normalisation
    let u = normalizeUrl(raw);
    if (!u) return '';

    // 2) Si deja wrapper, on extrait la cible
    if (u.includes(WRAPPER_MARKER)) {
      try {
        const uu = new URL(u);
        const src = uu.searchParams.get('src');
        if (src) {
          const decoded = decodeMany(src, 10);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        } else if (uu.hash && uu.hash.length > 1) {
          const decoded = decodeMany(uu.hash.slice(1), 8);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        }
      } catch (e) {
        const idx = u.indexOf('#');
        if (idx > -1 && idx < u.length - 1) {
          const decoded = decodeMany(u.slice(idx + 1), 8);
          if (/^https?:\/\//i.test(decoded)) u = decoded;
        }
      }
    }

    // 3) Externe : on laisse tel quel
    if (!u.includes('docs.getgrist.com')) return u;

    // 4) Pages "cles" : routes internes
    for (const r of GRIST_KEY_ROUTES) {
      if (u.includes(r.match)) return r.to;
    }

    // 5) Sinon : wrapper ?src=
    return WRAPPER_BASE + encodeURIComponent(u);
  }

  function navigateTop(url) {
    if (!url) return;

    const isPortalRoute = String(url).startsWith(PORTAL_ROOT + '#');

    try {
      const topWin = (window.top && window.top !== window) ? window.top : window;

      if (isPortalRoute) {
        // Si on est deja sur le portail, on ne change que le hash => pas de reload
        const current = String(topWin.location.href || '');
        if (current.includes('/guide/') && current.includes('preventionpaca.github.io')) {
          topWin.location.hash = String(url).split('#')[1] || '';
          return;
        }
      }

      topWin.location.href = url;
    } catch (e) {
      window.location.href = url;
    }
  }

  function buildTiles(blocsRowsAll, filInfoRows, layoutRow) {
    const grid = document.getElementById('tileGrid');
    grid.innerHTML = '';

    const layoutCols = layoutRow && layoutRow.Nbre_colonne
      ? Number(layoutRow.Nbre_colonne) || 4
      : 4;

    const maxBlocks = layoutRow && layoutRow.Nbre_Bloc
      ? Number(layoutRow.Nbre_Bloc) || blocsRowsAll.length
      : blocsRowsAll.length;

    if (!blocsRowsAll.length) {
      const msg = document.createElement('div');
      msg.style.gridColumn = '1 / -1';
      msg.style.padding = '12px 16px';
      msg.style.borderRadius = '12px';
      msg.style.background = 'rgba(220, 38, 38, 0.12)';
      msg.style.border = '1px solid rgba(248, 113, 113, 0.4)';
      msg.style.fontSize = '0.8rem';
      msg.textContent =
        `Aucun bloc trouvé pour la page "${PAGE_NAME}". ` +
        `Vérifie la colonne "Page" dans la table "Blocs".`;
      grid.appendChild(msg);
      return;
    }

    const blocsRows = blocsRowsAll
      .slice()
      .sort((a, b) => (a.num_bloc || 0) - (b.num_bloc || 0))
      .slice(0, maxBlocks);

    const nbBlocs = blocsRows.length;
    const cssCols = Math.min(layoutCols, nbBlocs || layoutCols);
    document.documentElement.style.setProperty('--grid-columns', cssCols);

    const cols = layoutCols;

    const counts = {};
    blocsRows.forEach(b => {
      const t = b.Titre_bloc || '';
      counts[t] = (counts[t] || 0) + 1;
    });
    const duplicates = new Set(Object.keys(counts).filter(t => counts[t] > 1));
    const already = new Set();

    const newsNorm = normalizeName('Fil info');
    const byTitle = {};
    blocsRows.forEach(b => {
      const t = b.Titre_bloc || '';
      if (!byTitle[t]) byTitle[t] = [];
      byTitle[t].push(b);
    });

    blocsRows.forEach(bloc => {
      const title = bloc.Titre_bloc || '';
      const dup = duplicates.has(title);
      if (dup) {
        if (already.has(title)) return;
        already.add(title);
      }

      const tile = document.createElement('div');
      tile.className = 'tile';

      const colorClass = colorToClass(bloc.Couleur);
      if (colorClass) tile.classList.add(colorClass);

      if (dup && byTitle[title].length === 2) {
        const [b1, b2] = byTitle[title].sort((x, y) => x.num_bloc - y.num_bloc);
        const pos1 = (b1.num_bloc || 1) - 1;
        const pos2 = (b2.num_bloc || 1) - 1;
        const r1 = Math.floor(pos1 / cols), c1 = pos1 % cols;
        const r2 = Math.floor(pos2 / cols), c2 = pos2 % cols;

        if (normalizeName(title) === newsNorm) {
          tile.classList.add('tile--tall');
        } else if (r1 === r2 && Math.abs(c1 - c2) === 1) {
          tile.classList.add('tile--wide');
        } else if (c1 === c2 && Math.abs(r1 - r2) === 1) {
          tile.classList.add('tile--tall');
        }
      }

      const icon = document.createElement('div');
      icon.className = 'tile-icon';
      icon.textContent = bloc.Initiale_bloc || '';
      tile.appendChild(icon);

      const main = document.createElement('div');
      main.className = 'tile-main';
      tile.appendChild(main);

      const titleEl = document.createElement('div');
      titleEl.className = 'tile-title';
      titleEl.textContent = title || '(sans titre)';
      main.appendChild(titleEl);

      const descEl = document.createElement('div');
      descEl.className = 'tile-desc';
      descEl.textContent = bloc.Sous_titre1 || '';
      main.appendChild(descEl);

      const isNews = normalizeName(title) === newsNorm;

      if (isNews && filInfoRows.length) {
        tile.style.cursor = 'default';

        const viewport = document.createElement('div');
        viewport.className = 'news-viewport';
        const track = document.createElement('div');
        track.className = 'news-track';
        viewport.appendChild(track);

        const makeItem = row => {
          const a = document.createElement('a');
          a.className = 'news-item';

          const t = row.Titre || '';
          const st = row.Sous_titre || '';
          const c = truncate(row.Contenu || '', 20);
          a.textContent = `${t} — ${st} : ${c}`;

          const url = makeWrapperUrl(row.Lien);
          if (url) {
            a.href   = url;
            a.target = '_top';
          } else {
            a.href = '#';
          }
          return a;
        };

        const items = filInfoRows.map(makeItem);
        [...items, ...items].forEach(it => track.appendChild(it));
        main.appendChild(viewport);

      } else {
        const sousG = bloc.Sous_titre_G;
        const sousD = bloc.Sous_titre_D;

        if (sousG || sousD) {
          const bottom = document.createElement('div');
          bottom.className = 'tile-bottom-links';

          if (sousG) {
            const aG = document.createElement('a');
            aG.className = 'tile-link';
            aG.textContent = sousG;
            if (bloc.Url_G) {
              const urlG = makeWrapperUrl(bloc.Url_G);
              if (urlG) {
                aG.href   = urlG;
                aG.target = '_top';
              } else {
                aG.href = '#';
              }
            } else {
              aG.href = '#';
            }
            bottom.appendChild(aG);
          }

          if (sousD) {
            const aD = document.createElement('a');
            aD.className = 'tile-link';
            aD.textContent = sousD;
            if (bloc.Url_D) {
              const urlD = makeWrapperUrl(bloc.Url_D);
              if (urlD) {
                aD.href   = urlD;
                aD.target = '_top';
              } else {
                aD.href = '#';
              }
            } else {
              aD.href = '#';
            }
            bottom.appendChild(aD);
          }

          main.appendChild(bottom);

        } else if (bloc.Url_bloc) {
          const urlBloc = makeWrapperUrl(bloc.Url_bloc);

          tile.addEventListener('click', () => {
            if (!urlBloc) return;
            navigateTop(urlBloc);
          });
          tile.tabIndex = 0;
          tile.setAttribute('role', 'link');
          tile.addEventListener('keypress', e => {
            if ((e.key === 'Enter' || e.key === ' ') && urlBloc) {
              e.preventDefault();
              navigateTop(urlBloc);
            }
          });
        }
      }

      grid.appendChild(tile);
    });
  }

  async function loadFromGrist() {
    const doc = (window.PP_IS_GRIST ? grist.docApi : null);

    const [tAgenc, tBlocs, tFil] = await Promise.all([
      PP_fetchTable('Agencement_portail'),
      PP_fetchTable('Blocs'),
      PP_fetchTable('Fil_info'),
    ]);

    const agRows   = rowsToRecordsCompat(tAgenc);
    const blocsAll = rowsToRecordsCompat(tBlocs);
    const filInfo  = rowsToRecordsCompat(tFil);

    const currentNorm = normalizeName(PAGE_NAME);
    let agencementName = PAGE_NAME;
    if (currentNorm === normalizeName('Portail')) {
      agencementName = 'Accueil';
    } else if (currentNorm === normalizeName('Acces_Admin')) {
      agencementName = 'Accès Admin';
    } else if (currentNorm === normalizeName('Acces_DDFPT')) {
      agencementName = 'Accès DDFPT';
    }

    const layoutRow =
      agRows.find(r => normalizeName(r.Page) === normalizeName(agencementName)) ||
      agRows[0] || null;

    const blocsRowsAll = blocsAll.filter(
      b => normalizeName(b.Page) === normalizeName(PAGE_NAME)
    );

    buildTiles(blocsRowsAll, filInfo, layoutRow);
  }

  function normalizeCode(v) {
    if (v === null || v === undefined) return '';
    return String(v).trim().replace(/\s+/g, '');
  }

  async function loadAdminCodes(doc) {
    try {
      const currentNorm = normalizeName(PAGE_NAME);

      // 1) Codes "admin" (table Administrateur)
      let adminList = [];
      try {
        const tAdmin = await doc.fetchTable(ADMIN_TABLE);
        const adminRows = rowsToRecordsCompat(tAdmin);

        adminList = adminRows
          .filter(r => {
            if (!r[ADMIN_FIELD_CODE]) return false;
            if (r[ADMIN_FIELD_PAGE]) {
              return normalizeName(r[ADMIN_FIELD_PAGE]) === currentNorm;
            }
            return true;
          })
          .map(r => normalizeCode(r[ADMIN_FIELD_CODE]))
          .filter(Boolean);
      } catch (e) {
        console.warn('Impossible de lire la table Administrateur:', e);
      }

      // 2) Codes "établissements" (colonne Code PACA)
      let etabList = [];
      try {
        const tEtab = await doc.fetchTable(ETAB_TABLE);
        const etabRows = rowsToRecordsCompat(tEtab);

        etabList = etabRows
          .map(r => normalizeCode(r[ETAB_FIELD_CODE]))
          .filter(Boolean);
      } catch (e) {
        console.warn('Impossible de lire la table établissements:', e);
      }

      // 3) Fusion + dédoublonnage
      adminCodes = Array.from(new Set([...adminList, ...etabList]));

      console.log('Codes DDFPT chargés (admin + établissements) :', adminCodes.length);
    } catch (err) {
      console.error('Erreur chargement codes DDFPT', err);
      adminCodes = [];
    }
  }

  function initAdminLock() {
    const overlay    = document.getElementById('ppLockOverlay');
    const input      = document.getElementById('ppLockInput');
    const errorEl    = document.getElementById('ppLockError');
    const attemptsEl = document.getElementById('ppLockAttempts');
    const btnSubmit  = document.getElementById('ppLockSubmit');
    const btnCancel  = document.getElementById('ppLockCancel');

    function updateAttempts() {
      const remaining = MAX_ATTEMPTS - attemptCount;
      if (remaining < MAX_ATTEMPTS && remaining > 0) {
        attemptsEl.textContent = 'Tentatives restantes : ' + remaining;
      } else if (remaining <= 0) {
        attemptsEl.textContent = 'Nombre maximal de tentatives atteint.';
      } else {
        attemptsEl.textContent = '';
      }
    }

    function refuse() {
      attemptCount++;
      updateAttempts();

      if (attemptCount >= MAX_ATTEMPTS) {
        errorEl.textContent = 'Accès refusé. Retour au portail…';
        setTimeout(() => {
          goHome();
        }, 800);
      } else {
        errorEl.textContent = 'Code incorrect. Merci de réessayer.';
        input.value = '';
        input.focus();
      }
    }

    function grantAccess() {
      if (accessGranted) return;
      accessGranted = true;
      overlay.style.transition = 'opacity 200ms ease-out';
      overlay.style.opacity = '1';
      requestAnimationFrame(() => {
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.style.display = 'none';
        }, 220);
      });
      loadFromGrist().catch(err => console.error('Erreur chargement Grist', err));
    }

    function handleSubmit() {
      if (accessGranted) return;

      const value = normalizeCode(input.value);
      if (!value) {
        errorEl.textContent = 'Merci de saisir un code.';
        return;
      }

      if (!adminCodes.length) {
        console.warn('Aucun code DDFPT trouvé : accès laissé libre.');
        grantAccess();
        return;
      }

      if (adminCodes.includes(value)) {
        grantAccess();
      } else {
        refuse();
      }
    }

    btnSubmit.addEventListener('click', handleSubmit);
    input.addEventListener('keypress', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleSubmit();
      }
    });

    // Annuler = retour direct au portail
    btnCancel.addEventListener('click', (e) => {
      errorEl.textContent = '';
      goHome(e);
    });

    updateAttempts();
    setTimeout(() => input.focus(), 50);
  }

  document.addEventListener('DOMContentLoaded', async () => {
    if (window.grist) {
      grist.ready();
      const doc = (window.PP_IS_GRIST ? grist.docApi : null);

      await loadAdminCodes(doc);

      const overlay = document.getElementById('ppLockOverlay');
      if (!adminCodes.length) {
        overlay.style.display = 'none';
        accessGranted = true;
        loadFromGrist().catch(err => console.error('Erreur chargement Grist', err));
      } else {
        initAdminLock();
      }
    } else {
      console.warn('Grist API non disponible');
    }
  });
</script>

<!-- Header commun + config (charger config avant header) -->
<script>
  window.PP_PAGE = "ddfpt";
</script>
<script src="../js/pp-config.js"></script>
<script src="../js/pp-header.js"></script>

</body>
</html>